/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * WES REST API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.6.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/api/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponse
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface FreeAvailability
 */
export interface FreeAvailability {
    /**
     * Date
     * @type {string}
     * @memberof FreeAvailability
     */
    date?: string;
    /**
     * Day of week
     * @type {string}
     * @memberof FreeAvailability
     */
    day_of_week?: string;
    /**
     * Type
     * @type {string}
     * @memberof FreeAvailability
     */
    type?: string;
    /**
     * Duration
     * @type {number}
     * @memberof FreeAvailability
     */
    duration?: number;
    /**
     * User id
     * @type {number}
     * @memberof FreeAvailability
     */
    user_id?: number;
}

/**
 * 
 * @export
 * @interface GetTokenForPasswordReset
 */
export interface GetTokenForPasswordReset {
    /**
     * Email for password reset.
     * @type {string}
     * @memberof GetTokenForPasswordReset
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array&lt;Message&gt;}
     * @memberof InlineResponse200
     */
    data?: Array<Message>;
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Message}
     * @memberof InlineResponse2001
     */
    data?: Message;
}

/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {Document}
     * @memberof InlineResponse20010
     */
    data?: Document;
}

/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {Array&lt;EvaluationsQuestion&gt;}
     * @memberof InlineResponse20011
     */
    data?: Array<EvaluationsQuestion>;
}

/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {NewEvaluationsQuestion}
     * @memberof InlineResponse20012
     */
    data?: NewEvaluationsQuestion;
}

/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {EvaluationsQuestion}
     * @memberof InlineResponse20013
     */
    data?: EvaluationsQuestion;
}

/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {Array&lt;Lesson&gt;}
     * @memberof InlineResponse20014
     */
    data?: Array<Lesson>;
}

/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {Lesson}
     * @memberof InlineResponse20015
     */
    data?: Lesson;
}

/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {Array&lt;LessonsMarker&gt;}
     * @memberof InlineResponse20016
     */
    data?: Array<LessonsMarker>;
}

/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * 
     * @type {LessonsMarker}
     * @memberof InlineResponse20017
     */
    data?: LessonsMarker;
}

/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * 
     * @type {Array&lt;LessonsReschedule&gt;}
     * @memberof InlineResponse20018
     */
    data?: Array<LessonsReschedule>;
}

/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * 
     * @type {NewLessonsReschedule}
     * @memberof InlineResponse20019
     */
    data?: NewLessonsReschedule;
}

/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array&lt;City&gt;}
     * @memberof InlineResponse2002
     */
    data?: Array<City>;
}

/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     * 
     * @type {LessonsReschedule}
     * @memberof InlineResponse20020
     */
    data?: LessonsReschedule;
}

/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * 
     * @type {Array&lt;Notification&gt;}
     * @memberof InlineResponse20021
     */
    data?: Array<Notification>;
}

/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * 
     * @type {Notification}
     * @memberof InlineResponse20022
     */
    data?: Notification;
}

/**
 * 
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * 
     * @type {Array&lt;ModelPackage&gt;}
     * @memberof InlineResponse20023
     */
    data?: Array<ModelPackage>;
}

/**
 * 
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * 
     * @type {ModelPackage}
     * @memberof InlineResponse20024
     */
    data?: ModelPackage;
}

/**
 * 
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * 
     * @type {Array&lt;User&gt;}
     * @memberof InlineResponse20025
     */
    data?: Array<User>;
}

/**
 * 
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * 
     * @type {Array&lt;PaymentSystem&gt;}
     * @memberof InlineResponse20026
     */
    data?: Array<PaymentSystem>;
}

/**
 * 
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * 
     * @type {PaymentSystem}
     * @memberof InlineResponse20027
     */
    data?: PaymentSystem;
}

/**
 * 
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * 
     * @type {Array&lt;PaymentLink&gt;}
     * @memberof InlineResponse20028
     */
    data?: Array<PaymentLink>;
}

/**
 * 
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * 
     * @type {Array&lt;PaymentTransaction&gt;}
     * @memberof InlineResponse20029
     */
    data?: Array<PaymentTransaction>;
}

/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {City}
     * @memberof InlineResponse2003
     */
    data?: City;
}

/**
 * 
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * 
     * @type {Array&lt;Quiz&gt;}
     * @memberof InlineResponse20030
     */
    data?: Array<Quiz>;
}

/**
 * 
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * 
     * @type {Quiz}
     * @memberof InlineResponse20031
     */
    data?: Quiz;
}

/**
 * 
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * 
     * @type {Array&lt;QuizMarker&gt;}
     * @memberof InlineResponse20032
     */
    data?: Array<QuizMarker>;
}

/**
 * 
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * 
     * @type {QuizMarker}
     * @memberof InlineResponse20033
     */
    data?: QuizMarker;
}

/**
 * 
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * 
     * @type {Array&lt;StatisticUpcomingLessons&gt;}
     * @memberof InlineResponse20034
     */
    data?: Array<StatisticUpcomingLessons>;
}

/**
 * 
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     * 
     * @type {StatisticCountersMonth}
     * @memberof InlineResponse20035
     */
    data?: StatisticCountersMonth;
}

/**
 * 
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * 
     * @type {StatisticOwed}
     * @memberof InlineResponse20036
     */
    data?: StatisticOwed;
}

/**
 * 
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * 
     * @type {StatisticPartnerTeacher}
     * @memberof InlineResponse20037
     */
    data?: StatisticPartnerTeacher;
}

/**
 * 
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * 
     * @type {Array&lt;StatisticEvaluations&gt;}
     * @memberof InlineResponse20038
     */
    data?: Array<StatisticEvaluations>;
}

/**
 * 
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     * 
     * @type {Array&lt;Transaction&gt;}
     * @memberof InlineResponse20039
     */
    data?: Array<Transaction>;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20039
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20039
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    data?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20040
     */
    data?: any;
}

/**
 * 
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * 
     * @type {Array&lt;NewTransaction&gt;}
     * @memberof InlineResponse20041
     */
    data?: Array<NewTransaction>;
}

/**
 * 
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
    /**
     * 
     * @type {Transaction}
     * @memberof InlineResponse20042
     */
    data?: Transaction;
}

/**
 * 
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
    /**
     * 
     * @type {User}
     * @memberof InlineResponse20043
     */
    data?: User;
}

/**
 * 
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
    /**
     * 
     * @type {PackageWithStudents}
     * @memberof InlineResponse20044
     */
    data?: PackageWithStudents;
}

/**
 * 
 * @export
 * @interface InlineResponse20045
 */
export interface InlineResponse20045 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045
     */
    token_type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045
     */
    access_token?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045
     */
    refresh_token?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20045
     */
    expires_in?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse20046
 */
export interface InlineResponse20046 {
    /**
     * 
     * @type {Array&lt;Transaction&gt;}
     * @memberof InlineResponse20046
     */
    data?: Array<Transaction>;
}

/**
 * 
 * @export
 * @interface InlineResponse20047
 */
export interface InlineResponse20047 {
    /**
     * 
     * @type {Array&lt;Invoice&gt;}
     * @memberof InlineResponse20047
     */
    data?: Array<Invoice>;
}

/**
 * 
 * @export
 * @interface InlineResponse20048
 */
export interface InlineResponse20048 {
    /**
     * 
     * @type {Array&lt;UsersEvaluation&gt;}
     * @memberof InlineResponse20048
     */
    data?: Array<UsersEvaluation>;
}

/**
 * 
 * @export
 * @interface InlineResponse20049
 */
export interface InlineResponse20049 {
    /**
     * 
     * @type {UsersEvaluation}
     * @memberof InlineResponse20049
     */
    data?: UsersEvaluation;
}

/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Array&lt;Country&gt;}
     * @memberof InlineResponse2005
     */
    data?: Array<Country>;
}

/**
 * 
 * @export
 * @interface InlineResponse20050
 */
export interface InlineResponse20050 {
    /**
     * 
     * @type {UpdateUsersEvaluation}
     * @memberof InlineResponse20050
     */
    data?: UpdateUsersEvaluation;
}

/**
 * 
 * @export
 * @interface InlineResponse20051
 */
export interface InlineResponse20051 {
    /**
     * 
     * @type {Array&lt;UserToUserFeedback&gt;}
     * @memberof InlineResponse20051
     */
    data?: Array<UserToUserFeedback>;
}

/**
 * 
 * @export
 * @interface InlineResponse20052
 */
export interface InlineResponse20052 {
    /**
     * 
     * @type {UserToUserFeedback}
     * @memberof InlineResponse20052
     */
    data?: UserToUserFeedback;
}

/**
 * 
 * @export
 * @interface InlineResponse20053
 */
export interface InlineResponse20053 {
    /**
     * 
     * @type {Array&lt;UsersAvailability&gt;}
     * @memberof InlineResponse20053
     */
    data?: Array<UsersAvailability>;
}

/**
 * 
 * @export
 * @interface InlineResponse20054
 */
export interface InlineResponse20054 {
    /**
     * 
     * @type {UsersAvailability}
     * @memberof InlineResponse20054
     */
    data?: UsersAvailability;
}

/**
 * 
 * @export
 * @interface InlineResponse20055
 */
export interface InlineResponse20055 {
    /**
     * 
     * @type {Array&lt;UsersBalance&gt;}
     * @memberof InlineResponse20055
     */
    data?: Array<UsersBalance>;
}

/**
 * 
 * @export
 * @interface InlineResponse20056
 */
export interface InlineResponse20056 {
    /**
     * 
     * @type {UsersBalance}
     * @memberof InlineResponse20056
     */
    data?: UsersBalance;
}

/**
 * 
 * @export
 * @interface InlineResponse20057
 */
export interface InlineResponse20057 {
    /**
     * 
     * @type {Array&lt;UsersDocument&gt;}
     * @memberof InlineResponse20057
     */
    data?: Array<UsersDocument>;
}

/**
 * 
 * @export
 * @interface InlineResponse20058
 */
export interface InlineResponse20058 {
    /**
     * 
     * @type {UsersDocument}
     * @memberof InlineResponse20058
     */
    data?: UsersDocument;
}

/**
 * 
 * @export
 * @interface InlineResponse20059
 */
export interface InlineResponse20059 {
    /**
     * 
     * @type {UpdateUsersDocument}
     * @memberof InlineResponse20059
     */
    data?: UpdateUsersDocument;
}

/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {Country}
     * @memberof InlineResponse2006
     */
    data?: Country;
}

/**
 * 
 * @export
 * @interface InlineResponse20060
 */
export interface InlineResponse20060 {
    /**
     * 
     * @type {Array&lt;UsersEvaluationTest&gt;}
     * @memberof InlineResponse20060
     */
    data?: Array<UsersEvaluationTest>;
}

/**
 * 
 * @export
 * @interface InlineResponse20061
 */
export interface InlineResponse20061 {
    /**
     * 
     * @type {NewUsersEvaluationTest}
     * @memberof InlineResponse20061
     */
    data?: NewUsersEvaluationTest;
}

/**
 * 
 * @export
 * @interface InlineResponse20062
 */
export interface InlineResponse20062 {
    /**
     * 
     * @type {UsersEvaluationTest}
     * @memberof InlineResponse20062
     */
    data?: UsersEvaluationTest;
}

/**
 * 
 * @export
 * @interface InlineResponse20063
 */
export interface InlineResponse20063 {
    /**
     * 
     * @type {UpdateUsersEvaluationTest}
     * @memberof InlineResponse20063
     */
    data?: UpdateUsersEvaluationTest;
}

/**
 * 
 * @export
 * @interface InlineResponse20064
 */
export interface InlineResponse20064 {
    /**
     * 
     * @type {Array&lt;UsersLesson&gt;}
     * @memberof InlineResponse20064
     */
    data?: Array<UsersLesson>;
}

/**
 * 
 * @export
 * @interface InlineResponse20065
 */
export interface InlineResponse20065 {
    /**
     * 
     * @type {UsersLesson}
     * @memberof InlineResponse20065
     */
    data?: UsersLesson;
}

/**
 * 
 * @export
 * @interface InlineResponse20066
 */
export interface InlineResponse20066 {
    /**
     * 
     * @type {UpdateUsersLesson}
     * @memberof InlineResponse20066
     */
    data?: UpdateUsersLesson;
}

/**
 * 
 * @export
 * @interface InlineResponse20067
 */
export interface InlineResponse20067 {
    /**
     * 
     * @type {Array&lt;UsersMarker&gt;}
     * @memberof InlineResponse20067
     */
    data?: Array<UsersMarker>;
}

/**
 * 
 * @export
 * @interface InlineResponse20068
 */
export interface InlineResponse20068 {
    /**
     * 
     * @type {UsersMarker}
     * @memberof InlineResponse20068
     */
    data?: UsersMarker;
}

/**
 * 
 * @export
 * @interface InlineResponse20069
 */
export interface InlineResponse20069 {
    /**
     * 
     * @type {UpdateUsersMarker}
     * @memberof InlineResponse20069
     */
    data?: UpdateUsersMarker;
}

/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {Array&lt;Discount&gt;}
     * @memberof InlineResponse2007
     */
    data?: Array<Discount>;
}

/**
 * 
 * @export
 * @interface InlineResponse20070
 */
export interface InlineResponse20070 {
    /**
     * 
     * @type {Array&lt;UsersMedia&gt;}
     * @memberof InlineResponse20070
     */
    data?: Array<UsersMedia>;
}

/**
 * 
 * @export
 * @interface InlineResponse20071
 */
export interface InlineResponse20071 {
    /**
     * 
     * @type {NewUsersMedia}
     * @memberof InlineResponse20071
     */
    data?: NewUsersMedia;
}

/**
 * 
 * @export
 * @interface InlineResponse20072
 */
export interface InlineResponse20072 {
    /**
     * 
     * @type {UsersMedia}
     * @memberof InlineResponse20072
     */
    data?: UsersMedia;
}

/**
 * 
 * @export
 * @interface InlineResponse20073
 */
export interface InlineResponse20073 {
    /**
     * 
     * @type {UpdateUsersMedia}
     * @memberof InlineResponse20073
     */
    data?: UpdateUsersMedia;
}

/**
 * 
 * @export
 * @interface InlineResponse20074
 */
export interface InlineResponse20074 {
    /**
     * 
     * @type {Array&lt;UsersQuiz&gt;}
     * @memberof InlineResponse20074
     */
    data?: Array<UsersQuiz>;
}

/**
 * 
 * @export
 * @interface InlineResponse20075
 */
export interface InlineResponse20075 {
    /**
     * 
     * @type {UsersQuiz}
     * @memberof InlineResponse20075
     */
    data?: UsersQuiz;
}

/**
 * 
 * @export
 * @interface InlineResponse20076
 */
export interface InlineResponse20076 {
    /**
     * 
     * @type {UpdateUsersQuiz}
     * @memberof InlineResponse20076
     */
    data?: UpdateUsersQuiz;
}

/**
 * 
 * @export
 * @interface InlineResponse20077
 */
export interface InlineResponse20077 {
    /**
     * 
     * @type {Array&lt;UsersRate&gt;}
     * @memberof InlineResponse20077
     */
    data?: Array<UsersRate>;
}

/**
 * 
 * @export
 * @interface InlineResponse20078
 */
export interface InlineResponse20078 {
    /**
     * 
     * @type {UsersRate}
     * @memberof InlineResponse20078
     */
    data?: UsersRate;
}

/**
 * 
 * @export
 * @interface InlineResponse20079
 */
export interface InlineResponse20079 {
    /**
     * 
     * @type {Array&lt;UsersRole&gt;}
     * @memberof InlineResponse20079
     */
    data?: Array<UsersRole>;
}

/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Discount}
     * @memberof InlineResponse2008
     */
    data?: Discount;
}

/**
 * 
 * @export
 * @interface InlineResponse20080
 */
export interface InlineResponse20080 {
    /**
     * 
     * @type {UsersRole}
     * @memberof InlineResponse20080
     */
    data?: UsersRole;
}

/**
 * 
 * @export
 * @interface InlineResponse20081
 */
export interface InlineResponse20081 {
    /**
     * 
     * @type {UpdateUsersRole}
     * @memberof InlineResponse20081
     */
    data?: UpdateUsersRole;
}

/**
 * 
 * @export
 * @interface InlineResponse20082
 */
export interface InlineResponse20082 {
    /**
     * 
     * @type {Array&lt;UsersStatistic&gt;}
     * @memberof InlineResponse20082
     */
    data?: Array<UsersStatistic>;
}

/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {Array&lt;Document&gt;}
     * @memberof InlineResponse2009
     */
    data?: Array<Document>;
}

/**
 * 
 * @export
 * @interface InviteLink
 */
export interface InviteLink {
    /**
     * Unique User ID
     * @type {number}
     * @memberof InviteLink
     */
    user_id?: number;
    /**
     * Link code
     * @type {string}
     * @memberof InviteLink
     */
    code?: string;
    /**
     * Email
     * @type {string}
     * @memberof InviteLink
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface InviteUser
 */
export interface InviteUser {
    /**
     * Email for invite.
     * @type {string}
     * @memberof InviteUser
     */
    email?: string;
    /**
     * role (ADMIN, PARTNER, TEACHER, STUDENT).
     * @type {string}
     * @memberof InviteUser
     */
    role?: string;
}

/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * End date point.
     * @type {string}
     * @memberof Invoice
     */
    end?: string;
    /**
     * Start date point.
     * @type {string}
     * @memberof Invoice
     */
    start?: string;
    /**
     * Json with transaction items.
     * @type {Array&lt;InvoiceItem&gt;}
     * @memberof Invoice
     */
    items?: Array<InvoiceItem>;
    /**
     * Total amount
     * @type {number}
     * @memberof Invoice
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface InvoiceItem
 */
export interface InvoiceItem {
    /**
     * Name
     * @type {string}
     * @memberof InvoiceItem
     */
    name?: string;
    /**
     * Price.
     * @type {number}
     * @memberof InvoiceItem
     */
    price?: number;
    /**
     * Quantity.
     * @type {number}
     * @memberof InvoiceItem
     */
    quantity?: number;
    /**
     * Count of lessons in this package.
     * @type {number}
     * @memberof InvoiceItem
     */
    Lessons_count?: number;
}

/**
 * 
 * @export
 * @interface Lesson
 */
export interface Lesson {
    /**
     * ID
     * @type {number}
     * @memberof Lesson
     */
    id?: number;
    /**
     * Package ID
     * @type {number}
     * @memberof Lesson
     */
    package_id: number;
    /**
     * Lesson date
     * @type {number}
     * @memberof Lesson
     */
    date: number;
    /**
     * Lesson duration
     * @type {string}
     * @memberof Lesson
     */
    duration?: Lesson.DurationEnum;
    /**
     * Title
     * @type {string}
     * @memberof Lesson
     */
    title: string;
    /**
     * Content
     * @type {string}
     * @memberof Lesson
     */
    content?: string;
    /**
     * Teacher ID
     * @type {number}
     * @memberof Lesson
     */
    teacher_id?: number;
    /**
     * Lesson Type
     * @type {string}
     * @memberof Lesson
     */
    type: Lesson.TypeEnum;
    /**
     * Lesson state
     * @type {string}
     * @memberof Lesson
     */
    state?: string;
}

/**
 * @export
 * @namespace Lesson
 */
export namespace Lesson {
    /**
     * @export
     * @enum {string}
     */
    export enum DurationEnum {
        SHORTLESSONDURATION = <any> 'SHORT_LESSON_DURATION',
        MIDLESSONDURATION = <any> 'MID_LESSON_DURATION',
        LONGLESSONDURATION = <any> 'LONG_LESSON_DURATION'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        INDIVIDUAL = <any> 'INDIVIDUAL',
        GROUP = <any> 'GROUP',
        TRIAL = <any> 'TRIAL',
        EVALUATION = <any> 'EVALUATION'
    }
}

/**
 * 
 * @export
 * @interface LessonStatistic
 */
export interface LessonStatistic {
    /**
     * Package ID
     * @type {any}
     * @memberof LessonStatistic
     */
    students_name: any;
    /**
     * ID
     * @type {number}
     * @memberof LessonStatistic
     */
    id?: number;
    /**
     * Package ID
     * @type {number}
     * @memberof LessonStatistic
     */
    package_id: number;
    /**
     * Lesson date
     * @type {number}
     * @memberof LessonStatistic
     */
    date: number;
    /**
     * Lesson duration
     * @type {string}
     * @memberof LessonStatistic
     */
    duration?: LessonStatistic.DurationEnum;
    /**
     * Title
     * @type {string}
     * @memberof LessonStatistic
     */
    title: string;
    /**
     * Content
     * @type {string}
     * @memberof LessonStatistic
     */
    content?: string;
    /**
     * Teacher ID
     * @type {number}
     * @memberof LessonStatistic
     */
    teacher_id?: number;
    /**
     * Lesson Type
     * @type {string}
     * @memberof LessonStatistic
     */
    type: LessonStatistic.TypeEnum;
    /**
     * Lesson state
     * @type {string}
     * @memberof LessonStatistic
     */
    state?: string;
}

/**
 * @export
 * @namespace LessonStatistic
 */
export namespace LessonStatistic {
    /**
     * @export
     * @enum {string}
     */
    export enum DurationEnum {
        SHORTLESSONDURATION = <any> 'SHORT_LESSON_DURATION',
        MIDLESSONDURATION = <any> 'MID_LESSON_DURATION',
        LONGLESSONDURATION = <any> 'LONG_LESSON_DURATION'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        INDIVIDUAL = <any> 'INDIVIDUAL',
        GROUP = <any> 'GROUP',
        TRIAL = <any> 'TRIAL',
        EVALUATION = <any> 'EVALUATION'
    }
}

/**
 * 
 * @export
 * @interface LessonZoom
 */
export interface LessonZoom {
    /**
     * ID
     * @type {number}
     * @memberof LessonZoom
     */
    id?: number;
    /**
     * Lesson ID
     * @type {number}
     * @memberof LessonZoom
     */
    lesson_id?: number;
    /**
     * Meeting data ID
     * @type {Array&lt;LessonZoomMeetingData&gt;}
     * @memberof LessonZoom
     */
    meeting_data?: Array<LessonZoomMeetingData>;
    /**
     * 
     * @type {LessonZoomRecordData}
     * @memberof LessonZoom
     */
    record_data?: LessonZoomRecordData;
    /**
     * Created data
     * @type {number}
     * @memberof LessonZoom
     */
    created_at?: number;
}

/**
 * 
 * @export
 * @interface LessonZoomMeetingData
 */
export interface LessonZoomMeetingData {
    /**
     * 
     * @type {number}
     * @memberof LessonZoomMeetingData
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomMeetingData
     */
    type?: number;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomMeetingData
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomMeetingData
     */
    topic?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomMeetingData
     */
    agenda?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomMeetingData
     */
    host_id?: string;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomMeetingData
     */
    duration?: number;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomMeetingData
     */
    join_url?: string;
    /**
     * 
     * @type {Array&lt;LessonZoomSettings&gt;}
     * @memberof LessonZoomMeetingData
     */
    settings?: Array<LessonZoomSettings>;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomMeetingData
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomMeetingData
     */
    start_url?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomMeetingData
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomMeetingData
     */
    start_time?: string;
}

/**
 * Record data ID
 * @export
 * @interface LessonZoomRecordData
 */
export interface LessonZoomRecordData {
    /**
     * 
     * @type {number}
     * @memberof LessonZoomRecordData
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomRecordData
     */
    type?: number;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordData
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordData
     */
    topic?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordData
     */
    host_id?: string;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomRecordData
     */
    duration?: number;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordData
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordData
     */
    agenda?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordData
     */
    join_url?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordData
     */
    start_time?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordData
     */
    account_id?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordData
     */
    total_size?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordData
     */
    recording_count?: string;
    /**
     * 
     * @type {Array&lt;LessonZoomRecordDataRecordingFiles&gt;}
     * @memberof LessonZoomRecordData
     */
    recording_files?: Array<LessonZoomRecordDataRecordingFiles>;
}

/**
 * 
 * @export
 * @interface LessonZoomRecordDataRecordingFiles
 */
export interface LessonZoomRecordDataRecordingFiles {
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordDataRecordingFiles
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordDataRecordingFiles
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordDataRecordingFiles
     */
    play_url?: string;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomRecordDataRecordingFiles
     */
    file_size?: number;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordDataRecordingFiles
     */
    file_type?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordDataRecordingFiles
     */
    meeting_id?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordDataRecordingFiles
     */
    download_url?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordDataRecordingFiles
     */
    recording_end?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordDataRecordingFiles
     */
    recording_type?: string;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomRecordDataRecordingFiles
     */
    recording_start?: string;
}

/**
 * 
 * @export
 * @interface LessonZoomSettings
 */
export interface LessonZoomSettings {
    /**
     * 
     * @type {string}
     * @memberof LessonZoomSettings
     */
    audio?: string;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomSettings
     */
    use_pmi?: number;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomSettings
     */
    watermark?: number;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomSettings
     */
    cn_meeting?: number;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomSettings
     */
    host_video?: number;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomSettings
     */
    in_meeting?: number;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomSettings
     */
    approval_type?: number;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomSettings
     */
    enforce_login?: number;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomSettings
     */
    auto_recording?: string;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomSettings
     */
    mute_upon_entry?: number;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomSettings
     */
    join_before_host?: number;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomSettings
     */
    alternative_hosts?: string;
    /**
     * 
     * @type {number}
     * @memberof LessonZoomSettings
     */
    participant_video?: number;
    /**
     * 
     * @type {string}
     * @memberof LessonZoomSettings
     */
    enforce_login_domains?: string;
}

/**
 * 
 * @export
 * @interface LessonsCount
 */
export interface LessonsCount {
    /**
     * Total lessons
     * @type {number}
     * @memberof LessonsCount
     */
    total?: number;
    /**
     * Done lessons
     * @type {number}
     * @memberof LessonsCount
     */
    done?: number;
}

/**
 * 
 * @export
 * @interface LessonsMarker
 */
export interface LessonsMarker {
    /**
     * Lesson ID
     * @type {number}
     * @memberof LessonsMarker
     */
    lesson_id: number;
    /**
     * Marker Code
     * @type {string}
     * @memberof LessonsMarker
     */
    code: string;
    /**
     * Value
     * @type {string}
     * @memberof LessonsMarker
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface LessonsSummary
 */
export interface LessonsSummary {
    /**
     * Users Lesson ID
     * @type {number}
     * @memberof LessonsSummary
     */
    users_lesson_id: number;
    /**
     * Description
     * @type {string}
     * @memberof LessonsSummary
     */
    description: string;
}

/**
 * 
 * @export
 * @interface ManyLessonsReschedule
 */
export interface ManyLessonsReschedule {
    /**
     * State
     * @type {string}
     * @memberof ManyLessonsReschedule
     */
    state?: string;
    /**
     * Lessons ids
     * @type {Array&lt;number&gt;}
     * @memberof ManyLessonsReschedule
     */
    lessons?: Array<number>;
}

/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * ID
     * @type {number}
     * @memberof Message
     */
    id?: number;
    /**
     * Content
     * @type {string}
     * @memberof Message
     */
    content: string;
    /**
     * User id
     * @type {number}
     * @memberof Message
     */
    user_id?: number;
    /**
     * Recipient id
     * @type {number}
     * @memberof Message
     */
    recipient_id?: number;
    /**
     * Created data
     * @type {number}
     * @memberof Message
     */
    created_at?: number;
    /**
     * Read
     * @type {number}
     * @memberof Message
     */
    read?: number;
}

/**
 * 
 * @export
 * @interface MetadataResponse
 */
export interface MetadataResponse {
    /**
     * 
     * @type {boolean}
     * @memberof MetadataResponse
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MetadataResponse
     */
    message?: string;
    /**
     * 
     * @type {MetadataResponseMetadata}
     * @memberof MetadataResponse
     */
    metadata?: MetadataResponseMetadata;
}

/**
 * 
 * @export
 * @interface MetadataResponseMetadata
 */
export interface MetadataResponseMetadata {
    /**
     * 
     * @type {number}
     * @memberof MetadataResponseMetadata
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface ModelPackage
 */
export interface ModelPackage {
    /**
     * ID
     * @type {number}
     * @memberof ModelPackage
     */
    id?: number;
    /**
     * Partner ID
     * @type {number}
     * @memberof ModelPackage
     */
    user_id: number;
    /**
     * Package name
     * @type {string}
     * @memberof ModelPackage
     */
    name: string;
    /**
     * Start Date
     * @type {number}
     * @memberof ModelPackage
     */
    start: number;
    /**
     * End Date
     * @type {number}
     * @memberof ModelPackage
     */
    ends: number;
    /**
     * Number of weeks
     * @type {number}
     * @memberof ModelPackage
     */
    number_of_weeks: number;
    /**
     * Number of hours
     * @type {number}
     * @memberof ModelPackage
     */
    number_of_hours: number;
    /**
     * Package type
     * @type {string}
     * @memberof ModelPackage
     */
    type: ModelPackage.TypeEnum;
    /**
     * Finish Date (end date + reserve weeks)
     * @type {number}
     * @memberof ModelPackage
     */
    finish?: number;
}

/**
 * @export
 * @namespace ModelPackage
 */
export namespace ModelPackage {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        INDIVIDUAL = <any> 'INDIVIDUAL',
        GROUP = <any> 'GROUP',
        TRIAL = <any> 'TRIAL',
        EVALUATION = <any> 'EVALUATION'
    }
}

/**
 * 
 * @export
 * @interface NewCity
 */
export interface NewCity {
    /**
     * name
     * @type {string}
     * @memberof NewCity
     */
    name: string;
    /**
     * Unique Country Code
     * @type {string}
     * @memberof NewCity
     */
    country_code?: string;
}

/**
 * 
 * @export
 * @interface NewCountry
 */
export interface NewCountry {
    /**
     * Name
     * @type {string}
     * @memberof NewCountry
     */
    name: string;
}

/**
 * 
 * @export
 * @interface NewDiscount
 */
export interface NewDiscount {
    /**
     * Frequency
     * @type {string}
     * @memberof NewDiscount
     */
    frequency: string;
    /**
     * Size in percents
     * @type {number}
     * @memberof NewDiscount
     */
    size?: number;
    /**
     * Hours From
     * @type {number}
     * @memberof NewDiscount
     */
    hours_from: number;
    /**
     * Hours To
     * @type {number}
     * @memberof NewDiscount
     */
    hours_to: number;
    /**
     * Due From
     * @type {string}
     * @memberof NewDiscount
     */
    due_from: string;
    /**
     * Due To
     * @type {string}
     * @memberof NewDiscount
     */
    due_to: string;
}

/**
 * 
 * @export
 * @interface NewDocument
 */
export interface NewDocument {
    /**
     * Title
     * @type {string}
     * @memberof NewDocument
     */
    title?: string;
    /**
     * Type
     * @type {string}
     * @memberof NewDocument
     */
    type?: string;
    /**
     * Content
     * @type {string}
     * @memberof NewDocument
     */
    content?: string;
}

/**
 * 
 * @export
 * @interface NewEvaluationsQuestion
 */
export interface NewEvaluationsQuestion {
    /**
     * Title
     * @type {string}
     * @memberof NewEvaluationsQuestion
     */
    title?: string;
    /**
     * Content
     * @type {string}
     * @memberof NewEvaluationsQuestion
     */
    content?: string;
    /**
     * Question Type
     * @type {string}
     * @memberof NewEvaluationsQuestion
     */
    type?: NewEvaluationsQuestion.TypeEnum;
    /**
     * Scenario
     * @type {string}
     * @memberof NewEvaluationsQuestion
     */
    scenario?: string;
}

/**
 * @export
 * @namespace NewEvaluationsQuestion
 */
export namespace NewEvaluationsQuestion {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CHOICE = <any> 'CHOICE',
        TEXT = <any> 'TEXT'
    }
}

/**
 * 
 * @export
 * @interface NewEvaluationsQuestionsVariant
 */
export interface NewEvaluationsQuestionsVariant {
    /**
     * Title
     * @type {string}
     * @memberof NewEvaluationsQuestionsVariant
     */
    title?: string;
    /**
     * Correct answer
     * @type {boolean}
     * @memberof NewEvaluationsQuestionsVariant
     */
    correct?: boolean;
}

/**
 * 
 * @export
 * @interface NewLesson
 */
export interface NewLesson {
    /**
     * Lesson date
     * @type {number}
     * @memberof NewLesson
     */
    date?: number;
    /**
     * Lesson duration
     * @type {string}
     * @memberof NewLesson
     */
    duration?: NewLesson.DurationEnum;
    /**
     * Title
     * @type {string}
     * @memberof NewLesson
     */
    title?: string;
    /**
     * Content
     * @type {string}
     * @memberof NewLesson
     */
    content?: string;
    /**
     * Teacher ID
     * @type {number}
     * @memberof NewLesson
     */
    teacher_id?: number;
    /**
     * Package ID
     * @type {number}
     * @memberof NewLesson
     */
    package_id?: number;
    /**
     * Lesson Type
     * @type {string}
     * @memberof NewLesson
     */
    type?: NewLesson.TypeEnum;
}

/**
 * @export
 * @namespace NewLesson
 */
export namespace NewLesson {
    /**
     * @export
     * @enum {string}
     */
    export enum DurationEnum {
        SHORTLESSONDURATION = <any> 'SHORT_LESSON_DURATION',
        MIDLESSONDURATION = <any> 'MID_LESSON_DURATION',
        LONGLESSONDURATION = <any> 'LONG_LESSON_DURATION'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        INDIVIDUAL = <any> 'INDIVIDUAL',
        GROUP = <any> 'GROUP',
        TRIAL = <any> 'TRIAL',
        EVALUATION = <any> 'EVALUATION'
    }
}

/**
 * 
 * @export
 * @interface NewLessonsForPackage
 */
export interface NewLessonsForPackage {
    /**
     * Teacher id
     * @type {number}
     * @memberof NewLessonsForPackage
     */
    teacher_id?: number;
    /**
     * 
     * @type {Array&lt;NewLessonsForPackageAvailability&gt;}
     * @memberof NewLessonsForPackage
     */
    availability?: Array<NewLessonsForPackageAvailability>;
}

/**
 * 
 * @export
 * @interface NewLessonsForPackageAvailability
 */
export interface NewLessonsForPackageAvailability {
    /**
     * 
     * @type {number}
     * @memberof NewLessonsForPackageAvailability
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof NewLessonsForPackageAvailability
     */
    end?: number;
    /**
     * 
     * @type {string}
     * @memberof NewLessonsForPackageAvailability
     */
    day_of_week?: string;
}

/**
 * 
 * @export
 * @interface NewLessonsMarker
 */
export interface NewLessonsMarker {
    /**
     * Marker Code
     * @type {string}
     * @memberof NewLessonsMarker
     */
    code: string;
    /**
     * Value
     * @type {string}
     * @memberof NewLessonsMarker
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface NewLessonsReschedule
 */
export interface NewLessonsReschedule {
    /**
     * Date
     * @type {number}
     * @memberof NewLessonsReschedule
     */
    date?: number;
    /**
     * Duration in second
     * @type {number}
     * @memberof NewLessonsReschedule
     */
    duration?: number;
    /**
     * User who initiates reschedule
     * @type {number}
     * @memberof NewLessonsReschedule
     */
    initiator_user_id?: number;
    /**
     * Message
     * @type {string}
     * @memberof NewLessonsReschedule
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface NewMessage
 */
export interface NewMessage {
    /**
     * Recipient Id
     * @type {number}
     * @memberof NewMessage
     */
    recipient_id: number;
    /**
     * Content
     * @type {string}
     * @memberof NewMessage
     */
    content: string;
}

/**
 * 
 * @export
 * @interface NewPackage
 */
export interface NewPackage {
    /**
     * Name
     * @type {string}
     * @memberof NewPackage
     */
    name?: string;
    /**
     * Package available from
     * @type {number}
     * @memberof NewPackage
     */
    start: number;
    /**
     * Package available to
     * @type {number}
     * @memberof NewPackage
     */
    ends: number;
    /**
     * Package in N weeks
     * @type {number}
     * @memberof NewPackage
     */
    number_of_weeks?: number;
    /**
     * Number of hours
     * @type {number}
     * @memberof NewPackage
     */
    number_of_hours?: number;
    /**
     * type
     * @type {string}
     * @memberof NewPackage
     */
    type: NewPackage.TypeEnum;
    /**
     * Partner id
     * @type {number}
     * @memberof NewPackage
     */
    user_id?: number;
    /**
     * Teacher id
     * @type {number}
     * @memberof NewPackage
     */
    teacher_id?: number;
    /**
     * 
     * @type {Array&lt;number&gt;}
     * @memberof NewPackage
     */
    students?: Array<number>;
}

/**
 * @export
 * @namespace NewPackage
 */
export namespace NewPackage {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        INDIVIDUAL = <any> 'INDIVIDUAL',
        GROUP = <any> 'GROUP',
        TRIAL = <any> 'TRIAL',
        EVALUATION = <any> 'EVALUATION'
    }
}

/**
 * 
 * @export
 * @interface NewPackageWithLessons
 */
export interface NewPackageWithLessons {
    /**
     * Name
     * @type {string}
     * @memberof NewPackageWithLessons
     */
    name?: string;
    /**
     * Package available from
     * @type {number}
     * @memberof NewPackageWithLessons
     */
    start: number;
    /**
     * Package in N weeks
     * @type {number}
     * @memberof NewPackageWithLessons
     */
    number_of_weeks?: number;
    /**
     * Number of hours
     * @type {number}
     * @memberof NewPackageWithLessons
     */
    number_of_hours?: number;
    /**
     * type
     * @type {string}
     * @memberof NewPackageWithLessons
     */
    type: NewPackageWithLessons.TypeEnum;
    /**
     * Partner id
     * @type {number}
     * @memberof NewPackageWithLessons
     */
    user_id?: number;
    /**
     * Teacher id
     * @type {number}
     * @memberof NewPackageWithLessons
     */
    teacher_id?: number;
    /**
     * 
     * @type {Array&lt;NewLessonsForPackageAvailability&gt;}
     * @memberof NewPackageWithLessons
     */
    availability?: Array<NewLessonsForPackageAvailability>;
    /**
     * 
     * @type {Array&lt;number&gt;}
     * @memberof NewPackageWithLessons
     */
    students?: Array<number>;
}

/**
 * @export
 * @namespace NewPackageWithLessons
 */
export namespace NewPackageWithLessons {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        INDIVIDUAL = <any> 'INDIVIDUAL',
        GROUP = <any> 'GROUP',
        TRIAL = <any> 'TRIAL',
        EVALUATION = <any> 'EVALUATION'
    }
}

/**
 * 
 * @export
 * @interface NewQuiz
 */
export interface NewQuiz {
    /**
     * Title
     * @type {string}
     * @memberof NewQuiz
     */
    title?: string;
    /**
     * Content
     * @type {string}
     * @memberof NewQuiz
     */
    content: string;
}

/**
 * 
 * @export
 * @interface NewQuizMarker
 */
export interface NewQuizMarker {
    /**
     * value
     * @type {string}
     * @memberof NewQuizMarker
     */
    value?: string;
    /**
     * code
     * @type {string}
     * @memberof NewQuizMarker
     */
    code: string;
}

/**
 * 
 * @export
 * @interface NewRescheduleAllLessons
 */
export interface NewRescheduleAllLessons {
    /**
     * Initiator User id
     * @type {number}
     * @memberof NewRescheduleAllLessons
     */
    initiator_user_id?: number;
    /**
     * Message
     * @type {string}
     * @memberof NewRescheduleAllLessons
     */
    message?: string;
    /**
     * 
     * @type {Array&lt;NewLessonsForPackageAvailability&gt;}
     * @memberof NewRescheduleAllLessons
     */
    availability?: Array<NewLessonsForPackageAvailability>;
}

/**
 * 
 * @export
 * @interface NewTransaction
 */
export interface NewTransaction {
    /**
     * Processor name of transaction
     * @type {string}
     * @memberof NewTransaction
     */
    processor: string;
    /**
     * Payload for transaction
     * @type {string}
     * @memberof NewTransaction
     */
    payload: string;
}

/**
 * 
 * @export
 * @interface NewUser
 */
export interface NewUser {
    /**
     * Name
     * @type {string}
     * @memberof NewUser
     */
    name: string;
    /**
     * First Name
     * @type {string}
     * @memberof NewUser
     */
    first_name?: string;
    /**
     * Last Name
     * @type {string}
     * @memberof NewUser
     */
    last_name?: string;
    /**
     * Email
     * @type {string}
     * @memberof NewUser
     */
    email: string;
    /**
     * Phone Number
     * @type {string}
     * @memberof NewUser
     */
    phone?: string;
    /**
     * Password
     * @type {string}
     * @memberof NewUser
     */
    password?: string;
    /**
     * Company Name
     * @type {string}
     * @memberof NewUser
     */
    company_name?: string;
    /**
     * Company Website
     * @type {string}
     * @memberof NewUser
     */
    company_website?: string;
    /**
     * Company Address
     * @type {string}
     * @memberof NewUser
     */
    company_address?: string;
    /**
     * City
     * @type {string}
     * @memberof NewUser
     */
    city?: string;
    /**
     * Country
     * @type {string}
     * @memberof NewUser
     */
    country?: string;
    /**
     * Photo
     * @type {string}
     * @memberof NewUser
     */
    photo?: string;
    /**
     * User timezone
     * @type {string}
     * @memberof NewUser
     */
    timezone?: string;
    /**
     * User facebook url
     * @type {string}
     * @memberof NewUser
     */
    facebook_url?: string;
    /**
     * User google url
     * @type {string}
     * @memberof NewUser
     */
    google_url?: string;
    /**
     * User youtube url
     * @type {string}
     * @memberof NewUser
     */
    youtube_url?: string;
}

/**
 * 
 * @export
 * @interface NewUserToUserFeedback
 */
export interface NewUserToUserFeedback {
    /**
     * User ID
     * @type {number}
     * @memberof NewUserToUserFeedback
     */
    user_id: number;
    /**
     * Feedback User ID
     * @type {number}
     * @memberof NewUserToUserFeedback
     */
    feedback_user_id: number;
    /**
     * User Comment
     * @type {string}
     * @memberof NewUserToUserFeedback
     */
    comment: string;
}

/**
 * 
 * @export
 * @interface NewUsersAvailability
 */
export interface NewUsersAvailability {
    /**
     * Date in timestamp
     * @type {number}
     * @memberof NewUsersAvailability
     */
    date?: number;
    /**
     * Day of week
     * @type {string}
     * @memberof NewUsersAvailability
     */
    day_of_week?: NewUsersAvailability.DayOfWeekEnum;
    /**
     * Type
     * @type {string}
     * @memberof NewUsersAvailability
     */
    type?: NewUsersAvailability.TypeEnum;
    /**
     * Duration in minutes
     * @type {number}
     * @memberof NewUsersAvailability
     */
    duration: number;
}

/**
 * @export
 * @namespace NewUsersAvailability
 */
export namespace NewUsersAvailability {
    /**
     * @export
     * @enum {string}
     */
    export enum DayOfWeekEnum {
        SUN = <any> 'SUN',
        MON = <any> 'MON',
        TUE = <any> 'TUE',
        WED = <any> 'WED',
        THU = <any> 'THU',
        FRI = <any> 'FRI',
        SAT = <any> 'SAT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        DATE = <any> 'DATE',
        DAYOFWEEK = <any> 'DAY_OF_WEEK'
    }
}

/**
 * 
 * @export
 * @interface NewUsersBalance
 */
export interface NewUsersBalance {
    /**
     * Amount of transaction. Can be negative.
     * @type {number}
     * @memberof NewUsersBalance
     */
    balance: number;
}

/**
 * 
 * @export
 * @interface NewUsersDocument
 */
export interface NewUsersDocument {
    /**
     * Document name
     * @type {string}
     * @memberof NewUsersDocument
     */
    document_name: string;
    /**
     * Document in base64
     * @type {string}
     * @memberof NewUsersDocument
     */
    document: string;
}

/**
 * 
 * @export
 * @interface NewUsersEvaluation
 */
export interface NewUsersEvaluation {
    /**
     * Teacher Id
     * @type {number}
     * @memberof NewUsersEvaluation
     */
    teacher_id: number;
    /**
     * Rate
     * @type {number}
     * @memberof NewUsersEvaluation
     */
    rate: number;
    /**
     * Content
     * @type {string}
     * @memberof NewUsersEvaluation
     */
    content?: string;
    /**
     * Comment
     * @type {string}
     * @memberof NewUsersEvaluation
     */
    comment?: string;
    /**
     * Type
     * @type {string}
     * @memberof NewUsersEvaluation
     */
    type: NewUsersEvaluation.TypeEnum;
}

/**
 * @export
 * @namespace NewUsersEvaluation
 */
export namespace NewUsersEvaluation {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        GRAMMAR = <any> 'GRAMMAR',
        WRITING = <any> 'WRITING',
        SPEAKING = <any> 'SPEAKING',
        LISTENING = <any> 'LISTENING'
    }
}

/**
 * 
 * @export
 * @interface NewUsersEvaluationTest
 */
export interface NewUsersEvaluationTest {
    /**
     * Evaluations question Id
     * @type {number}
     * @memberof NewUsersEvaluationTest
     */
    evaluations_question_id: number;
    /**
     * Rate
     * @type {number}
     * @memberof NewUsersEvaluationTest
     */
    rate: number;
    /**
     * answer
     * @type {string}
     * @memberof NewUsersEvaluationTest
     */
    answer: string;
}

/**
 * 
 * @export
 * @interface NewUsersLesson
 */
export interface NewUsersLesson {
    /**
     * Lesson Id
     * @type {number}
     * @memberof NewUsersLesson
     */
    lesson_id: number;
}

/**
 * 
 * @export
 * @interface NewUsersMarker
 */
export interface NewUsersMarker {
    /**
     * Marker code
     * @type {string}
     * @memberof NewUsersMarker
     */
    code: string;
    /**
     * Marker type
     * @type {string}
     * @memberof NewUsersMarker
     */
    type: string;
    /**
     * Value
     * @type {string}
     * @memberof NewUsersMarker
     */
    value: string;
}

/**
 * 
 * @export
 * @interface NewUsersMedia
 */
export interface NewUsersMedia {
    /**
     * Media file
     * @type {string}
     * @memberof NewUsersMedia
     */
    media: string;
    /**
     * Media file name
     * @type {string}
     * @memberof NewUsersMedia
     */
    media_name?: string;
    /**
     * User Id
     * @type {number}
     * @memberof NewUsersMedia
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface NewUsersQuiz
 */
export interface NewUsersQuiz {
    /**
     * Quiz Id
     * @type {number}
     * @memberof NewUsersQuiz
     */
    quiz_id: number;
    /**
     * Answer
     * @type {string}
     * @memberof NewUsersQuiz
     */
    answer: string;
}

/**
 * 
 * @export
 * @interface NewUsersRate
 */
export interface NewUsersRate {
    /**
     * Teacher Rate
     * @type {number}
     * @memberof NewUsersRate
     */
    individual_rate: number;
    /**
     * Teacher Rate
     * @type {number}
     * @memberof NewUsersRate
     */
    allow_overtime?: number;
    /**
     * Teacher Rate
     * @type {number}
     * @memberof NewUsersRate
     */
    hours_per_week?: number;
    /**
     * Teacher Rate
     * @type {number}
     * @memberof NewUsersRate
     */
    months?: number;
    /**
     * Teacher Rate
     * @type {string}
     * @memberof NewUsersRate
     */
    start_date?: string;
}

/**
 * 
 * @export
 * @interface NewUsersRole
 */
export interface NewUsersRole {
    /**
     * Role
     * @type {string}
     * @memberof NewUsersRole
     */
    role: string;
}

/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * ID
     * @type {string}
     * @memberof Notification
     */
    id?: string;
    /**
     * Notification class.
     * @type {string}
     * @memberof Notification
     */
    type?: string;
    /**
     * Notifiable (user) id.
     * @type {string}
     * @memberof Notification
     */
    notifiable_id?: string;
    /**
     * Notifiable (user)  class
     * @type {string}
     * @memberof Notification
     */
    notifiable_type?: string;
    /**
     * Involved (user) id.
     * @type {string}
     * @memberof Notification
     */
    involved_id?: string;
    /**
     * Involved (user)  class
     * @type {string}
     * @memberof Notification
     */
    involved_type?: string;
    /**
     * JSON with custom data
     * @type {any}
     * @memberof Notification
     */
    data?: any;
    /**
     * Read at. If this property equals null - this is unread notification.
     * @type {string}
     * @memberof Notification
     */
    read_at?: string;
    /**
     * Created rate date
     * @type {string}
     * @memberof Notification
     */
    created_at?: string;
    /**
     * Notifications tag
     * @type {string}
     * @memberof Notification
     */
    tag?: Notification.TagEnum;
    /**
     * Notifications actions
     * @type {any}
     * @memberof Notification
     */
    actions?: any;
}

/**
 * @export
 * @namespace Notification
 */
export namespace Notification {
    /**
     * @export
     * @enum {string}
     */
    export enum TagEnum {
        ALERT = <any> 'ALERT',
        REGULAR = <any> 'REGULAR',
        INVITEUSER = <any> 'INVITE_USER'
    }
}

/**
 * 
 * @export
 * @interface PackageWithStudents
 */
export interface PackageWithStudents {
    /**
     * ID
     * @type {number}
     * @memberof PackageWithStudents
     */
    id?: number;
    /**
     * Partner ID
     * @type {number}
     * @memberof PackageWithStudents
     */
    user_id?: number;
    /**
     * Package name
     * @type {string}
     * @memberof PackageWithStudents
     */
    name?: string;
    /**
     * Start Date
     * @type {number}
     * @memberof PackageWithStudents
     */
    start?: number;
    /**
     * End Date
     * @type {number}
     * @memberof PackageWithStudents
     */
    ends?: number;
    /**
     * Number of weeks
     * @type {number}
     * @memberof PackageWithStudents
     */
    number_of_weeks?: number;
    /**
     * Number of hours
     * @type {number}
     * @memberof PackageWithStudents
     */
    number_of_hours?: number;
    /**
     * Package type
     * @type {string}
     * @memberof PackageWithStudents
     */
    type?: string;
    /**
     * Finish Date (end date + reserve weeks)
     * @type {number}
     * @memberof PackageWithStudents
     */
    finish?: number;
    /**
     * 
     * @type {Array&lt;User&gt;}
     * @memberof PackageWithStudents
     */
    students?: Array<User>;
}

/**
 * 
 * @export
 * @interface PasswordReset
 */
export interface PasswordReset {
    /**
     * Old password
     * @type {string}
     * @memberof PasswordReset
     */
    password?: string;
    /**
     * New password
     * @type {string}
     * @memberof PasswordReset
     */
    new_password?: string;
    /**
     * New password confirmation
     * @type {string}
     * @memberof PasswordReset
     */
    new_password_confirmation?: string;
}

/**
 * 
 * @export
 * @interface PaymentLink
 */
export interface PaymentLink {
    /**
     * Redirect link for payment system.
     * @type {string}
     * @memberof PaymentLink
     */
    payment_link?: string;
}

/**
 * 
 * @export
 * @interface PaymentSystem
 */
export interface PaymentSystem {
    /**
     * Code
     * @type {string}
     * @memberof PaymentSystem
     */
    code: string;
}

/**
 * 
 * @export
 * @interface PaymentTransaction
 */
export interface PaymentTransaction {
    /**
     * Transaction id
     * @type {number}
     * @memberof PaymentTransaction
     */
    id?: number;
    /**
     * User ID
     * @type {number}
     * @memberof PaymentTransaction
     */
    user_id?: number;
    /**
     * Json with transaction items.
     * @type {string}
     * @memberof PaymentTransaction
     */
    items?: string;
    /**
     * Transaction token
     * @type {string}
     * @memberof PaymentTransaction
     */
    token?: string;
    /**
     * Json with transaction details.
     * @type {string}
     * @memberof PaymentTransaction
     */
    transaction_details?: string;
}

/**
 * 
 * @export
 * @interface ReadMessages
 */
export interface ReadMessages {
    /**
     * 
     * @type {Array&lt;number&gt;}
     * @memberof ReadMessages
     */
    messages?: Array<number>;
}

/**
 * 
 * @export
 * @interface StatisticCountersMonth
 */
export interface StatisticCountersMonth {
    /**
     * Lessons all
     * @type {number}
     * @memberof StatisticCountersMonth
     */
    all_lessons: number;
    /**
     * Lessons This month.
     * @type {number}
     * @memberof StatisticCountersMonth
     */
    lessons_count: number;
    /**
     * Lessons Monthly average
     * @type {number}
     * @memberof StatisticCountersMonth
     */
    average_lessons: number;
    /**
     * Price per lesson
     * @type {number}
     * @memberof StatisticCountersMonth
     */
    price_per_lesson: number;
    /**
     * Profit per lesson
     * @type {number}
     * @memberof StatisticCountersMonth
     */
    profit_per_lesson: number;
}

/**
 * 
 * @export
 * @interface StatisticEvaluations
 */
export interface StatisticEvaluations {
    /**
     * Month and year
     * @type {string}
     * @memberof StatisticEvaluations
     */
    period?: string;
    /**
     * Grammar rate avg
     * @type {number}
     * @memberof StatisticEvaluations
     */
    grammar?: number;
    /**
     * Writing rate avg
     * @type {number}
     * @memberof StatisticEvaluations
     */
    writing?: number;
    /**
     * Speaking rate avg
     * @type {number}
     * @memberof StatisticEvaluations
     */
    speaking?: number;
    /**
     * Listening rate avg
     * @type {number}
     * @memberof StatisticEvaluations
     */
    listening?: number;
}

/**
 * 
 * @export
 * @interface StatisticOwed
 */
export interface StatisticOwed {
    /**
     * 
     * @type {Array&lt;UserOwed&gt;}
     * @memberof StatisticOwed
     */
    teachers: Array<UserOwed>;
    /**
     * 
     * @type {Array&lt;UserOwed&gt;}
     * @memberof StatisticOwed
     */
    partners: Array<UserOwed>;
}

/**
 * 
 * @export
 * @interface StatisticPartnerTeacher
 */
export interface StatisticPartnerTeacher {
    /**
     * Lessons all
     * @type {number}
     * @memberof StatisticPartnerTeacher
     */
    all_lessons: number;
    /**
     * Lessons This month.
     * @type {number}
     * @memberof StatisticPartnerTeacher
     */
    month_lessons: number;
    /**
     * Lessons Monthly average
     * @type {number}
     * @memberof StatisticPartnerTeacher
     */
    average_lessons: number;
    /**
     * Yearly total
     * @type {number}
     * @memberof StatisticPartnerTeacher
     */
    yearly_total: number;
    /**
     * Number of students
     * @type {number}
     * @memberof StatisticPartnerTeacher
     */
    number_of_students: number;
}

/**
 * 
 * @export
 * @interface StatisticUpcomingLessons
 */
export interface StatisticUpcomingLessons {
    /**
     * 
     * @type {Array&lt;LessonStatistic&gt;}
     * @memberof StatisticUpcomingLessons
     */
    lesson: Array<LessonStatistic>;
    /**
     * 
     * @type {Array&lt;NewPackage&gt;}
     * @memberof StatisticUpcomingLessons
     */
    _package: Array<NewPackage>;
    /**
     * Lessons number of package
     * @type {number}
     * @memberof StatisticUpcomingLessons
     */
    lesson_number_in_package: number;
}

/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Transaction ID
     * @type {number}
     * @memberof Transaction
     */
    id?: number;
    /**
     * Type of transaction
     * @type {string}
     * @memberof Transaction
     */
    type?: string;
    /**
     * Transaction payload
     * @type {string}
     * @memberof Transaction
     */
    payload: string;
    /**
     * Total amount of transaction
     * @type {number}
     * @memberof Transaction
     */
    total?: number;
    /**
     * Purpose of transaction.
     * @type {string}
     * @memberof Transaction
     */
    purpose?: string;
    /**
     * Transaction creating date.
     * @type {string}
     * @memberof Transaction
     */
    created_at?: string;
}

/**
 * 
 * @export
 * @interface UpdateDiscount
 */
export interface UpdateDiscount {
    /**
     * Frequency
     * @type {string}
     * @memberof UpdateDiscount
     */
    frequency?: string;
    /**
     * Size in percents
     * @type {number}
     * @memberof UpdateDiscount
     */
    size?: number;
    /**
     * Hours From
     * @type {number}
     * @memberof UpdateDiscount
     */
    hours_from?: number;
    /**
     * Hours To
     * @type {number}
     * @memberof UpdateDiscount
     */
    hours_to?: number;
    /**
     * Due From
     * @type {string}
     * @memberof UpdateDiscount
     */
    due_from?: string;
    /**
     * Due To
     * @type {string}
     * @memberof UpdateDiscount
     */
    due_to?: string;
}

/**
 * 
 * @export
 * @interface UpdateDiscountState
 */
export interface UpdateDiscountState {
    /**
     * state
     * @type {string}
     * @memberof UpdateDiscountState
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface UpdateDocumentState
 */
export interface UpdateDocumentState {
    /**
     * state
     * @type {string}
     * @memberof UpdateDocumentState
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface UpdateLessonsMarker
 */
export interface UpdateLessonsMarker {
    /**
     * Value
     * @type {string}
     * @memberof UpdateLessonsMarker
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface UpdateLessonsReschedule
 */
export interface UpdateLessonsReschedule {
    /**
     * From Date
     * @type {number}
     * @memberof UpdateLessonsReschedule
     */
    date?: number;
    /**
     * Duration
     * @type {number}
     * @memberof UpdateLessonsReschedule
     */
    duration?: number;
    /**
     * User who initiates reschedule
     * @type {number}
     * @memberof UpdateLessonsReschedule
     */
    initiator_user_id?: number;
    /**
     * Message
     * @type {string}
     * @memberof UpdateLessonsReschedule
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface UpdatePackage
 */
export interface UpdatePackage {
    /**
     * Name
     * @type {string}
     * @memberof UpdatePackage
     */
    name?: string;
    /**
     * Package available from
     * @type {string}
     * @memberof UpdatePackage
     */
    start?: string;
    /**
     * Package available to
     * @type {string}
     * @memberof UpdatePackage
     */
    ends?: string;
    /**
     * Package in N weeks
     * @type {number}
     * @memberof UpdatePackage
     */
    number_of_weeks?: number;
    /**
     * Number of hours
     * @type {number}
     * @memberof UpdatePackage
     */
    number_of_hours?: number;
    /**
     * type
     * @type {string}
     * @memberof UpdatePackage
     */
    type?: UpdatePackage.TypeEnum;
    /**
     * Partner id
     * @type {number}
     * @memberof UpdatePackage
     */
    user_id?: number;
}

/**
 * @export
 * @namespace UpdatePackage
 */
export namespace UpdatePackage {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        INDIVIDUAL = <any> 'INDIVIDUAL',
        GROUP = <any> 'GROUP',
        TRIAL = <any> 'TRIAL',
        EVALUATION = <any> 'EVALUATION'
    }
}

/**
 * 
 * @export
 * @interface UpdatePackageState
 */
export interface UpdatePackageState {
    /**
     * state
     * @type {string}
     * @memberof UpdatePackageState
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface UpdatePaymentSystemState
 */
export interface UpdatePaymentSystemState {
    /**
     * state
     * @type {string}
     * @memberof UpdatePaymentSystemState
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface UpdateQuizState
 */
export interface UpdateQuizState {
    /**
     * state
     * @type {string}
     * @memberof UpdateQuizState
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface UpdateUser
 */
export interface UpdateUser {
    /**
     * First Name
     * @type {string}
     * @memberof UpdateUser
     */
    name: string;
    /**
     * Second Name
     * @type {string}
     * @memberof UpdateUser
     */
    second_name?: string;
    /**
     * Last Name
     * @type {string}
     * @memberof UpdateUser
     */
    last_name?: string;
    /**
     * Email
     * @type {string}
     * @memberof UpdateUser
     */
    email: string;
    /**
     * Phone Number
     * @type {string}
     * @memberof UpdateUser
     */
    phone?: string;
    /**
     * Company Name
     * @type {string}
     * @memberof UpdateUser
     */
    company_name?: string;
    /**
     * Company Website
     * @type {string}
     * @memberof UpdateUser
     */
    company_website?: string;
    /**
     * Company Address
     * @type {string}
     * @memberof UpdateUser
     */
    company_address?: string;
    /**
     * City
     * @type {string}
     * @memberof UpdateUser
     */
    city?: string;
    /**
     * Country
     * @type {string}
     * @memberof UpdateUser
     */
    country?: string;
    /**
     * Photo
     * @type {string}
     * @memberof UpdateUser
     */
    photo?: string;
    /**
     * User timezone
     * @type {string}
     * @memberof UpdateUser
     */
    timezone?: string;
    /**
     * User facebook url
     * @type {string}
     * @memberof UpdateUser
     */
    facebook_url?: string;
    /**
     * User google url
     * @type {string}
     * @memberof UpdateUser
     */
    google_url?: string;
    /**
     * User youtube url
     * @type {string}
     * @memberof UpdateUser
     */
    youtube_url?: string;
}

/**
 * 
 * @export
 * @interface UpdateUserLessonState
 */
export interface UpdateUserLessonState {
    /**
     * state
     * @type {string}
     * @memberof UpdateUserLessonState
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface UpdateUserRescheduleState
 */
export interface UpdateUserRescheduleState {
    /**
     * state
     * @type {string}
     * @memberof UpdateUserRescheduleState
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface UpdateUserState
 */
export interface UpdateUserState {
    /**
     * state
     * @type {string}
     * @memberof UpdateUserState
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface UpdateUsersAvailability
 */
export interface UpdateUsersAvailability {
    /**
     * Date
     * @type {string}
     * @memberof UpdateUsersAvailability
     */
    date?: string;
    /**
     * Day of week
     * @type {string}
     * @memberof UpdateUsersAvailability
     */
    day_of_week?: UpdateUsersAvailability.DayOfWeekEnum;
    /**
     * Type
     * @type {string}
     * @memberof UpdateUsersAvailability
     */
    type?: UpdateUsersAvailability.TypeEnum;
    /**
     * Duration in minutes
     * @type {number}
     * @memberof UpdateUsersAvailability
     */
    duration?: number;
}

/**
 * @export
 * @namespace UpdateUsersAvailability
 */
export namespace UpdateUsersAvailability {
    /**
     * @export
     * @enum {string}
     */
    export enum DayOfWeekEnum {
        SUN = <any> 'SUN',
        MON = <any> 'MON',
        TUE = <any> 'TUE',
        WED = <any> 'WED',
        THU = <any> 'THU',
        FRI = <any> 'FRI',
        SAT = <any> 'SAT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        DATE = <any> 'DATE',
        DAYOFWEEK = <any> 'DAY_OF_WEEK'
    }
}

/**
 * 
 * @export
 * @interface UpdateUsersDocument
 */
export interface UpdateUsersDocument {
    /**
     * User Document Id
     * @type {number}
     * @memberof UpdateUsersDocument
     */
    user_document_id?: number;
    /**
     * Document name
     * @type {string}
     * @memberof UpdateUsersDocument
     */
    document_name: string;
    /**
     * Document in base64
     * @type {string}
     * @memberof UpdateUsersDocument
     */
    document?: string;
}

/**
 * 
 * @export
 * @interface UpdateUsersEvaluation
 */
export interface UpdateUsersEvaluation {
    /**
     * Teacher Id
     * @type {number}
     * @memberof UpdateUsersEvaluation
     */
    teacher_id: number;
    /**
     * Rate
     * @type {number}
     * @memberof UpdateUsersEvaluation
     */
    rate: number;
    /**
     * Content
     * @type {string}
     * @memberof UpdateUsersEvaluation
     */
    content?: string;
    /**
     * Comment
     * @type {string}
     * @memberof UpdateUsersEvaluation
     */
    comment?: string;
    /**
     * Type
     * @type {string}
     * @memberof UpdateUsersEvaluation
     */
    type: UpdateUsersEvaluation.TypeEnum;
}

/**
 * @export
 * @namespace UpdateUsersEvaluation
 */
export namespace UpdateUsersEvaluation {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        GRAMMAR = <any> 'GRAMMAR',
        WRITING = <any> 'WRITING',
        SPEAKING = <any> 'SPEAKING',
        LISTENING = <any> 'LISTENING'
    }
}

/**
 * 
 * @export
 * @interface UpdateUsersEvaluationTest
 */
export interface UpdateUsersEvaluationTest {
    /**
     * Evaluations question Id
     * @type {number}
     * @memberof UpdateUsersEvaluationTest
     */
    evaluations_question_id: number;
    /**
     * Rate
     * @type {number}
     * @memberof UpdateUsersEvaluationTest
     */
    rate: number;
    /**
     * answer
     * @type {string}
     * @memberof UpdateUsersEvaluationTest
     */
    answer: string;
}

/**
 * 
 * @export
 * @interface UpdateUsersLesson
 */
export interface UpdateUsersLesson {
    /**
     * Lesson Id
     * @type {number}
     * @memberof UpdateUsersLesson
     */
    lesson_id: number;
}

/**
 * 
 * @export
 * @interface UpdateUsersMarker
 */
export interface UpdateUsersMarker {
    /**
     * Marker code
     * @type {string}
     * @memberof UpdateUsersMarker
     */
    code: string;
    /**
     * Value
     * @type {string}
     * @memberof UpdateUsersMarker
     */
    value: string;
}

/**
 * 
 * @export
 * @interface UpdateUsersMedia
 */
export interface UpdateUsersMedia {
    /**
     * Media file
     * @type {string}
     * @memberof UpdateUsersMedia
     */
    media: string;
    /**
     * Media file name
     * @type {string}
     * @memberof UpdateUsersMedia
     */
    media_name?: string;
    /**
     * User Id
     * @type {number}
     * @memberof UpdateUsersMedia
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface UpdateUsersQuiz
 */
export interface UpdateUsersQuiz {
    /**
     * Quiz Id
     * @type {number}
     * @memberof UpdateUsersQuiz
     */
    quiz_id: number;
    /**
     * Answer
     * @type {string}
     * @memberof UpdateUsersQuiz
     */
    answer: string;
}

/**
 * 
 * @export
 * @interface UpdateUsersRole
 */
export interface UpdateUsersRole {
    /**
     * Role
     * @type {string}
     * @memberof UpdateUsersRole
     */
    role: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * First Name
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * Second Name
     * @type {string}
     * @memberof User
     */
    second_name?: string;
    /**
     * Last Name
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * Email
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * Photo
     * @type {string}
     * @memberof User
     */
    photo?: string;
    /**
     * Phone Number
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * Password
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * Company Name
     * @type {string}
     * @memberof User
     */
    company_name?: string;
    /**
     * Company Website
     * @type {string}
     * @memberof User
     */
    company_website?: string;
    /**
     * Company Address
     * @type {string}
     * @memberof User
     */
    company_address?: string;
    /**
     * City
     * @type {string}
     * @memberof User
     */
    city?: string;
    /**
     * ID
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * Timezone
     * @type {number}
     * @memberof User
     */
    timezone?: number;
    /**
     * User facebook url
     * @type {string}
     * @memberof User
     */
    facebook_url?: string;
    /**
     * User google url
     * @type {string}
     * @memberof User
     */
    google_url?: string;
    /**
     * User youtube url
     * @type {string}
     * @memberof User
     */
    youtube_url?: string;
    /**
     * County name
     * @type {string}
     * @memberof User
     */
    country?: string;
    /**
     * Student lessons count
     * @type {LessonsCount}
     * @memberof User
     */
    lessons_count?: LessonsCount;
    /**
     * Current balance
     * @type {number}
     * @memberof User
     */
    balance?: number;
    /**
     * Last activity
     * @type {string}
     * @memberof User
     */
    last_seen?: string;
    /**
     * Trial mode boolean
     * @type {boolean}
     * @memberof User
     */
    is_trial?: boolean;
    /**
     * 
     * @type {Array&lt;ModelPackage&gt;}
     * @memberof User
     */
    active_packages?: Array<ModelPackage>;
    /**
     * Trial start since this date.
     * @type {string}
     * @memberof User
     */
    start_trial_date?: string;
    /**
     * Timezone shift (seconds)
     * @type {number}
     * @memberof User
     */
    tz_shift?: number;
}

/**
 * 
 * @export
 * @interface UserOwed
 */
export interface UserOwed {
    /**
     * 
     * @type {any}
     * @memberof UserOwed
     */
    owed?: any;
    /**
     * First Name
     * @type {string}
     * @memberof UserOwed
     */
    name?: string;
    /**
     * Second Name
     * @type {string}
     * @memberof UserOwed
     */
    second_name?: string;
    /**
     * Last Name
     * @type {string}
     * @memberof UserOwed
     */
    last_name?: string;
    /**
     * Email
     * @type {string}
     * @memberof UserOwed
     */
    email?: string;
    /**
     * Photo
     * @type {string}
     * @memberof UserOwed
     */
    photo?: string;
    /**
     * Phone Number
     * @type {string}
     * @memberof UserOwed
     */
    phone?: string;
    /**
     * Password
     * @type {string}
     * @memberof UserOwed
     */
    password?: string;
    /**
     * Company Name
     * @type {string}
     * @memberof UserOwed
     */
    company_name?: string;
    /**
     * Company Website
     * @type {string}
     * @memberof UserOwed
     */
    company_website?: string;
    /**
     * Company Address
     * @type {string}
     * @memberof UserOwed
     */
    company_address?: string;
    /**
     * City
     * @type {string}
     * @memberof UserOwed
     */
    city?: string;
    /**
     * ID
     * @type {number}
     * @memberof UserOwed
     */
    id?: number;
    /**
     * Timezone
     * @type {number}
     * @memberof UserOwed
     */
    timezone?: number;
    /**
     * User facebook url
     * @type {string}
     * @memberof UserOwed
     */
    facebook_url?: string;
    /**
     * User google url
     * @type {string}
     * @memberof UserOwed
     */
    google_url?: string;
    /**
     * User youtube url
     * @type {string}
     * @memberof UserOwed
     */
    youtube_url?: string;
    /**
     * County name
     * @type {string}
     * @memberof UserOwed
     */
    country?: string;
    /**
     * Student lessons count
     * @type {LessonsCount}
     * @memberof UserOwed
     */
    lessons_count?: LessonsCount;
    /**
     * Current balance
     * @type {number}
     * @memberof UserOwed
     */
    balance?: number;
    /**
     * Last activity
     * @type {string}
     * @memberof UserOwed
     */
    last_seen?: string;
    /**
     * Trial mode boolean
     * @type {boolean}
     * @memberof UserOwed
     */
    is_trial?: boolean;
    /**
     * 
     * @type {Array&lt;ModelPackage&gt;}
     * @memberof UserOwed
     */
    active_packages?: Array<ModelPackage>;
    /**
     * Trial start since this date.
     * @type {string}
     * @memberof UserOwed
     */
    start_trial_date?: string;
    /**
     * Timezone shift (seconds)
     * @type {number}
     * @memberof UserOwed
     */
    tz_shift?: number;
}

/**
 * 
 * @export
 * @interface UserToUserFeedback
 */
export interface UserToUserFeedback {
    /**
     * ID
     * @type {number}
     * @memberof UserToUserFeedback
     */
    id?: number;
    /**
     * User ID
     * @type {number}
     * @memberof UserToUserFeedback
     */
    user_id: number;
    /**
     * Feedback User ID
     * @type {number}
     * @memberof UserToUserFeedback
     */
    feedback_user_id: number;
    /**
     * User Comment
     * @type {string}
     * @memberof UserToUserFeedback
     */
    comment: string;
}

/**
 * 
 * @export
 * @interface UsersAvailability
 */
export interface UsersAvailability {
    /**
     * ID
     * @type {number}
     * @memberof UsersAvailability
     */
    id?: number;
    /**
     * Date in timestamp
     * @type {number}
     * @memberof UsersAvailability
     */
    date?: number;
    /**
     * Day of week
     * @type {string}
     * @memberof UsersAvailability
     */
    day_of_week?: UsersAvailability.DayOfWeekEnum;
    /**
     * Type
     * @type {string}
     * @memberof UsersAvailability
     */
    type?: UsersAvailability.TypeEnum;
    /**
     * Duration in minutes
     * @type {number}
     * @memberof UsersAvailability
     */
    duration?: number;
}

/**
 * @export
 * @namespace UsersAvailability
 */
export namespace UsersAvailability {
    /**
     * @export
     * @enum {string}
     */
    export enum DayOfWeekEnum {
        SUN = <any> 'SUN',
        MON = <any> 'MON',
        TUE = <any> 'TUE',
        WED = <any> 'WED',
        THU = <any> 'THU',
        FRI = <any> 'FRI',
        SAT = <any> 'SAT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        DATE = <any> 'DATE',
        DAYOFWEEK = <any> 'DAY_OF_WEEK'
    }
}

/**
 * 
 * @export
 * @interface UsersBalance
 */
export interface UsersBalance {
    /**
     * ID
     * @type {number}
     * @memberof UsersBalance
     */
    id?: number;
    /**
     * User ID
     * @type {number}
     * @memberof UsersBalance
     */
    user_id: number;
    /**
     * Current balance stamp.
     * @type {number}
     * @memberof UsersBalance
     */
    balance: number;
    /**
     * Amount of transaction. Can be negative.
     * @type {number}
     * @memberof UsersBalance
     */
    delta?: number;
}

/**
 * 
 * @export
 * @interface UsersDocument
 */
export interface UsersDocument {
    /**
     * ID
     * @type {number}
     * @memberof UsersDocument
     */
    id?: number;
    /**
     * Document ID
     * @type {number}
     * @memberof UsersDocument
     */
    document_id: number;
    /**
     * User ID
     * @type {number}
     * @memberof UsersDocument
     */
    user_id: number;
    /**
     * Document
     * @type {string}
     * @memberof UsersDocument
     */
    document?: string;
    /**
     * Document path
     * @type {string}
     * @memberof UsersDocument
     */
    document_path?: string;
    /**
     * Document name
     * @type {string}
     * @memberof UsersDocument
     */
    document_name?: string;
}

/**
 * 
 * @export
 * @interface UsersEvaluation
 */
export interface UsersEvaluation {
    /**
     * User ID
     * @type {number}
     * @memberof UsersEvaluation
     */
    user_id: number;
    /**
     * User ID
     * @type {number}
     * @memberof UsersEvaluation
     */
    teacher_id?: number;
    /**
     * Rate
     * @type {number}
     * @memberof UsersEvaluation
     */
    rate: number;
    /**
     * Comment
     * @type {string}
     * @memberof UsersEvaluation
     */
    comment?: string;
    /**
     * Content
     * @type {string}
     * @memberof UsersEvaluation
     */
    content?: string;
    /**
     * type
     * @type {string}
     * @memberof UsersEvaluation
     */
    type?: string;
    /**
     * Created rate date
     * @type {string}
     * @memberof UsersEvaluation
     */
    created_at?: string;
}

/**
 * 
 * @export
 * @interface UsersExtended
 */
export interface UsersExtended {
    /**
     * 
     * @type {User}
     * @memberof UsersExtended
     */
    user?: User;
    /**
     * Evaluation Score
     * @type {number}
     * @memberof UsersExtended
     */
    evaluation_score?: number;
    /**
     * 
     * @type {Array&lt;ModelPackage&gt;}
     * @memberof UsersExtended
     */
    active_packages?: Array<ModelPackage>;
    /**
     * 
     * @type {Array&lt;User&gt;}
     * @memberof UsersExtended
     */
    teachers?: Array<User>;
}

/**
 * 
 * @export
 * @interface UsersLesson
 */
export interface UsersLesson {
    /**
     * ID
     * @type {number}
     * @memberof UsersLesson
     */
    id?: number;
    /**
     * Lesson ID
     * @type {number}
     * @memberof UsersLesson
     */
    lesson_id: number;
    /**
     * User ID
     * @type {number}
     * @memberof UsersLesson
     */
    user_id: number;
}

/**
 * 
 * @export
 * @interface UsersMarker
 */
export interface UsersMarker {
    /**
     * User unique ID
     * @type {number}
     * @memberof UsersMarker
     */
    user_id: number;
    /**
     * Code
     * @type {string}
     * @memberof UsersMarker
     */
    code: string;
    /**
     * Type
     * @type {string}
     * @memberof UsersMarker
     */
    type?: string;
    /**
     * Value
     * @type {string}
     * @memberof UsersMarker
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface UsersMedia
 */
export interface UsersMedia {
    /**
     * User ID
     * @type {number}
     * @memberof UsersMedia
     */
    user_id: number;
    /**
     * Media file name
     * @type {string}
     * @memberof UsersMedia
     */
    media: string;
    /**
     * Media file path
     * @type {string}
     * @memberof UsersMedia
     */
    media_path?: string;
}

/**
 * 
 * @export
 * @interface UsersQuiz
 */
export interface UsersQuiz {
    /**
     * User unique ID
     * @type {number}
     * @memberof UsersQuiz
     */
    user_id: number;
    /**
     * Unique Quiz ID
     * @type {number}
     * @memberof UsersQuiz
     */
    quiz_id: number;
    /**
     * Answer
     * @type {string}
     * @memberof UsersQuiz
     */
    answer: string;
}

/**
 * 
 * @export
 * @interface UsersRole
 */
export interface UsersRole {
    /**
     * User ID
     * @type {number}
     * @memberof UsersRole
     */
    user_id: number;
    /**
     * Role
     * @type {string}
     * @memberof UsersRole
     */
    role: string;
}

/**
 * 
 * @export
 * @interface UsersStatistic
 */
export interface UsersStatistic {
    /**
     * Id
     * @type {number}
     * @memberof UsersStatistic
     */
    id?: number;
    /**
     * Student Id
     * @type {number}
     * @memberof UsersStatistic
     */
    student_id?: number;
    /**
     * Package Id
     * @type {number}
     * @memberof UsersStatistic
     */
    package_id?: number;
    /**
     * Partner Id
     * @type {number}
     * @memberof UsersStatistic
     */
    partner_id?: number;
    /**
     * Start date package
     * @type {number}
     * @memberof UsersStatistic
     */
    start_package?: number;
    /**
     * Ends date package
     * @type {number}
     * @memberof UsersStatistic
     */
    ends_package?: number;
    /**
     * Student name
     * @type {string}
     * @memberof UsersStatistic
     */
    student_name?: string;
    /**
     * Package name
     * @type {string}
     * @memberof UsersStatistic
     */
    package_name?: string;
    /**
     * Speaking score
     * @type {number}
     * @memberof UsersStatistic
     */
    speaking_score?: number;
    /**
     * Speaking score previous
     * @type {number}
     * @memberof UsersStatistic
     */
    speaking_score_previous?: number;
    /**
     * Speaking score raised
     * @type {number}
     * @memberof UsersStatistic
     */
    speaking_score_raised?: number;
    /**
     * Writing score
     * @type {number}
     * @memberof UsersStatistic
     */
    writing_score?: number;
    /**
     * Writing score raised
     * @type {number}
     * @memberof UsersStatistic
     */
    writing_score_raised?: number;
    /**
     * Writing score previous
     * @type {number}
     * @memberof UsersStatistic
     */
    writing_score_previous?: number;
    /**
     * Grammar score
     * @type {number}
     * @memberof UsersStatistic
     */
    grammar_score?: number;
    /**
     * Grammar score raised
     * @type {number}
     * @memberof UsersStatistic
     */
    grammar_score_raised?: number;
    /**
     * Grammar score
     * @type {number}
     * @memberof UsersStatistic
     */
    grammar_score_previous?: number;
    /**
     * Listening score
     * @type {number}
     * @memberof UsersStatistic
     */
    listening_score?: number;
    /**
     * Listening score raised
     * @type {number}
     * @memberof UsersStatistic
     */
    listening_score_raised?: number;
    /**
     * Listening score previous
     * @type {number}
     * @memberof UsersStatistic
     */
    listening_score_previous?: number;
    /**
     * Holistic score
     * @type {string}
     * @memberof UsersStatistic
     */
    holistic_score?: string;
    /**
     * Lessons left
     * @type {string}
     * @memberof UsersStatistic
     */
    lessons_left?: string;
}

/**
 * 
 * @export
 * @interface City
 */
export interface City {
    /**
     * name
     * @type {string}
     * @memberof City
     */
    name: string;
    /**
     * Unique Country Code
     * @type {string}
     * @memberof City
     */
    country_code?: string;
}

/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * Name
     * @type {string}
     * @memberof Country
     */
    name: string;
}

/**
 * 
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * Frequency
     * @type {string}
     * @memberof Discount
     */
    frequency: string;
    /**
     * Size in percents
     * @type {number}
     * @memberof Discount
     */
    size?: number;
    /**
     * Hours From
     * @type {number}
     * @memberof Discount
     */
    hours_from: number;
    /**
     * Hours To
     * @type {number}
     * @memberof Discount
     */
    hours_to: number;
    /**
     * Due From
     * @type {string}
     * @memberof Discount
     */
    due_from: string;
    /**
     * Due To
     * @type {string}
     * @memberof Discount
     */
    due_to: string;
}

/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * Title
     * @type {string}
     * @memberof Document
     */
    title?: string;
    /**
     * Type
     * @type {string}
     * @memberof Document
     */
    type?: string;
    /**
     * Content
     * @type {string}
     * @memberof Document
     */
    content?: string;
}

/**
 * 
 * @export
 * @interface EvaluationsQuestion
 */
export interface EvaluationsQuestion {
    /**
     * Title
     * @type {string}
     * @memberof EvaluationsQuestion
     */
    title?: string;
    /**
     * Content
     * @type {string}
     * @memberof EvaluationsQuestion
     */
    content?: string;
    /**
     * Question Type
     * @type {string}
     * @memberof EvaluationsQuestion
     */
    type?: EvaluationsQuestion.TypeEnum;
    /**
     * Scenario
     * @type {string}
     * @memberof EvaluationsQuestion
     */
    scenario?: string;
}

/**
 * @export
 * @namespace EvaluationsQuestion
 */
export namespace EvaluationsQuestion {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CHOICE = <any> 'CHOICE',
        TEXT = <any> 'TEXT'
    }
}

/**
 * 
 * @export
 * @interface EvaluationsQuestionsVariant
 */
export interface EvaluationsQuestionsVariant {
    /**
     * Title
     * @type {string}
     * @memberof EvaluationsQuestionsVariant
     */
    title?: string;
    /**
     * Correct answer
     * @type {boolean}
     * @memberof EvaluationsQuestionsVariant
     */
    correct?: boolean;
}

/**
 * 
 * @export
 * @interface LessonsReschedule
 */
export interface LessonsReschedule {
    /**
     * Date
     * @type {number}
     * @memberof LessonsReschedule
     */
    date?: number;
    /**
     * Duration in second
     * @type {number}
     * @memberof LessonsReschedule
     */
    duration?: number;
    /**
     * User who initiates reschedule
     * @type {number}
     * @memberof LessonsReschedule
     */
    initiator_user_id?: number;
    /**
     * Message
     * @type {string}
     * @memberof LessonsReschedule
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface Quiz
 */
export interface Quiz {
    /**
     * Title
     * @type {string}
     * @memberof Quiz
     */
    title?: string;
    /**
     * Content
     * @type {string}
     * @memberof Quiz
     */
    content: string;
}

/**
 * 
 * @export
 * @interface QuizMarker
 */
export interface QuizMarker {
    /**
     * value
     * @type {string}
     * @memberof QuizMarker
     */
    value?: string;
    /**
     * code
     * @type {string}
     * @memberof QuizMarker
     */
    code: string;
}

/**
 * 
 * @export
 * @interface UsersEvaluationTest
 */
export interface UsersEvaluationTest {
    /**
     * Evaluations question Id
     * @type {number}
     * @memberof UsersEvaluationTest
     */
    evaluations_question_id: number;
    /**
     * Rate
     * @type {number}
     * @memberof UsersEvaluationTest
     */
    rate: number;
    /**
     * answer
     * @type {string}
     * @memberof UsersEvaluationTest
     */
    answer: string;
}

/**
 * 
 * @export
 * @interface UsersRate
 */
export interface UsersRate {
    /**
     * Teacher Rate
     * @type {number}
     * @memberof UsersRate
     */
    individual_rate: number;
    /**
     * Teacher Rate
     * @type {number}
     * @memberof UsersRate
     */
    allow_overtime?: number;
    /**
     * Teacher Rate
     * @type {number}
     * @memberof UsersRate
     */
    hours_per_week?: number;
    /**
     * Teacher Rate
     * @type {number}
     * @memberof UsersRate
     */
    months?: number;
    /**
     * Teacher Rate
     * @type {string}
     * @memberof UsersRate
     */
    start_date?: string;
}


/**
 * CityApi - fetch parameter creator
 * @export
 */
export const CityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all Cities
         * @summary Get a listing of the Cities.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {boolean} [enabled] Enabled
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesGet(offset: number, limit: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling citiesGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling citiesGet.');
            }
            const localVarPath = `/cities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete City
         * @summary Remove the specified City from storage
         * @param {number} id id of City
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling citiesIdDelete.');
            }
            const localVarPath = `/cities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get City
         * @summary Display the specified City
         * @param {number} id id of City
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesIdGet(id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling citiesIdGet.');
            }
            const localVarPath = `/cities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update City
         * @summary Update the specified City in storage
         * @param {number} id id of City
         * @param {NewCity} [body] City that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesIdPut(id: number, body?: NewCity, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling citiesIdPut.');
            }
            const localVarPath = `/cities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewCity" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store City
         * @summary Store a newly created City in storage
         * @param {City} [body] City that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesPost(body?: City, options: any = {}): FetchArgs {
            const localVarPath = `/cities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"City" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CityApi - functional programming interface
 * @export
 */
export const CityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all Cities
         * @summary Get a listing of the Cities.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {boolean} [enabled] Enabled
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesGet(offset: number, limit: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = CityApiFetchParamCreator(configuration).citiesGet(offset, limit, search, sort_order, enabled, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete City
         * @summary Remove the specified City from storage
         * @param {number} id id of City
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = CityApiFetchParamCreator(configuration).citiesIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get City
         * @summary Display the specified City
         * @param {number} id id of City
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = CityApiFetchParamCreator(configuration).citiesIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update City
         * @summary Update the specified City in storage
         * @param {number} id id of City
         * @param {NewCity} [body] City that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesIdPut(id: number, body?: NewCity, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = CityApiFetchParamCreator(configuration).citiesIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store City
         * @summary Store a newly created City in storage
         * @param {City} [body] City that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesPost(body?: City, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = CityApiFetchParamCreator(configuration).citiesPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CityApi - factory interface
 * @export
 */
export const CityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all Cities
         * @summary Get a listing of the Cities.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {boolean} [enabled] Enabled
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesGet(offset: number, limit: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return CityApiFp(configuration).citiesGet(offset, limit, search, sort_order, enabled, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Delete City
         * @summary Remove the specified City from storage
         * @param {number} id id of City
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesIdDelete(id: number, options?: any) {
            return CityApiFp(configuration).citiesIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get City
         * @summary Display the specified City
         * @param {number} id id of City
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return CityApiFp(configuration).citiesIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update City
         * @summary Update the specified City in storage
         * @param {number} id id of City
         * @param {NewCity} [body] City that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesIdPut(id: number, body?: NewCity, options?: any) {
            return CityApiFp(configuration).citiesIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Store City
         * @summary Store a newly created City in storage
         * @param {City} [body] City that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        citiesPost(body?: City, options?: any) {
            return CityApiFp(configuration).citiesPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * CityApi - object-oriented interface
 * @export
 * @class CityApi
 * @extends {BaseAPI}
 */
export class CityApi extends BaseAPI {
    /**
     * Get all Cities
     * @summary Get a listing of the Cities.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [enabled] Enabled
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public citiesGet(offset: number, limit: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return CityApiFp(this.configuration).citiesGet(offset, limit, search, sort_order, enabled, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Delete City
     * @summary Remove the specified City from storage
     * @param {} id id of City
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public citiesIdDelete(id: number, options?: any) {
        return CityApiFp(this.configuration).citiesIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get City
     * @summary Display the specified City
     * @param {} id id of City
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public citiesIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return CityApiFp(this.configuration).citiesIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update City
     * @summary Update the specified City in storage
     * @param {} id id of City
     * @param {} [body] City that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public citiesIdPut(id: number, body?: NewCity, options?: any) {
        return CityApiFp(this.configuration).citiesIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store City
     * @summary Store a newly created City in storage
     * @param {} [body] City that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public citiesPost(body?: City, options?: any) {
        return CityApiFp(this.configuration).citiesPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * CountryApi - fetch parameter creator
 * @export
 */
export const CountryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete Country
         * @summary Remove the specified Country from storage
         * @param {string} code Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCodeDelete(code: string, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling countriesCodeDelete.');
            }
            const localVarPath = `/countries/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Country
         * @summary Display the specified Country
         * @param {string} code Country code
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCodeGet(code: string, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling countriesCodeGet.');
            }
            const localVarPath = `/countries/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Country
         * @summary Update the specified Country in storage
         * @param {string} code Country code
         * @param {NewCountry} [body] Country that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCodePut(code: string, body?: NewCountry, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling countriesCodePut.');
            }
            const localVarPath = `/countries/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewCountry" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Countries
         * @summary Get a listing of the Countries.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {boolean} [enabled] Enabled
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGet(offset: number, limit: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling countriesGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling countriesGet.');
            }
            const localVarPath = `/countries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Countries
         * @summary Get a listing of the Countries.
         * @param {&#39;ru&#39; | &#39;en&#39;} locale Country locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesListGet(locale: 'ru' | 'en', options: any = {}): FetchArgs {
            // verify required parameter 'locale' is not null or undefined
            if (locale === null || locale === undefined) {
                throw new RequiredError('locale','Required parameter locale was null or undefined when calling countriesListGet.');
            }
            const localVarPath = `/countries/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store Country
         * @summary Store a newly created Country in storage
         * @param {Country} [body] Country that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesPost(body?: Country, options: any = {}): FetchArgs {
            const localVarPath = `/countries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Country" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryApi - functional programming interface
 * @export
 */
export const CountryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete Country
         * @summary Remove the specified Country from storage
         * @param {string} code Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCodeDelete(code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = CountryApiFetchParamCreator(configuration).countriesCodeDelete(code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Country
         * @summary Display the specified Country
         * @param {string} code Country code
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCodeGet(code: string, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = CountryApiFetchParamCreator(configuration).countriesCodeGet(code, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Country
         * @summary Update the specified Country in storage
         * @param {string} code Country code
         * @param {NewCountry} [body] Country that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCodePut(code: string, body?: NewCountry, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = CountryApiFetchParamCreator(configuration).countriesCodePut(code, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Countries
         * @summary Get a listing of the Countries.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {boolean} [enabled] Enabled
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGet(offset: number, limit: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = CountryApiFetchParamCreator(configuration).countriesGet(offset, limit, search, sort_order, enabled, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Countries
         * @summary Get a listing of the Countries.
         * @param {&#39;ru&#39; | &#39;en&#39;} locale Country locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesListGet(locale: 'ru' | 'en', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = CountryApiFetchParamCreator(configuration).countriesListGet(locale, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store Country
         * @summary Store a newly created Country in storage
         * @param {Country} [body] Country that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesPost(body?: Country, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = CountryApiFetchParamCreator(configuration).countriesPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CountryApi - factory interface
 * @export
 */
export const CountryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete Country
         * @summary Remove the specified Country from storage
         * @param {string} code Country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCodeDelete(code: string, options?: any) {
            return CountryApiFp(configuration).countriesCodeDelete(code, options)(fetch, basePath);
        },
        /**
         * Get Country
         * @summary Display the specified Country
         * @param {string} code Country code
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCodeGet(code: string, _with?: string, fields?: string, scenario?: string, options?: any) {
            return CountryApiFp(configuration).countriesCodeGet(code, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update Country
         * @summary Update the specified Country in storage
         * @param {string} code Country code
         * @param {NewCountry} [body] Country that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCodePut(code: string, body?: NewCountry, options?: any) {
            return CountryApiFp(configuration).countriesCodePut(code, body, options)(fetch, basePath);
        },
        /**
         * Get all Countries
         * @summary Get a listing of the Countries.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {boolean} [enabled] Enabled
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGet(offset: number, limit: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return CountryApiFp(configuration).countriesGet(offset, limit, search, sort_order, enabled, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get all Countries
         * @summary Get a listing of the Countries.
         * @param {&#39;ru&#39; | &#39;en&#39;} locale Country locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesListGet(locale: 'ru' | 'en', options?: any) {
            return CountryApiFp(configuration).countriesListGet(locale, options)(fetch, basePath);
        },
        /**
         * Store Country
         * @summary Store a newly created Country in storage
         * @param {Country} [body] Country that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesPost(body?: Country, options?: any) {
            return CountryApiFp(configuration).countriesPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * CountryApi - object-oriented interface
 * @export
 * @class CountryApi
 * @extends {BaseAPI}
 */
export class CountryApi extends BaseAPI {
    /**
     * Delete Country
     * @summary Remove the specified Country from storage
     * @param {} code Country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countriesCodeDelete(code: string, options?: any) {
        return CountryApiFp(this.configuration).countriesCodeDelete(code, options)(this.fetch, this.basePath);
    }

    /**
     * Get Country
     * @summary Display the specified Country
     * @param {} code Country code
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countriesCodeGet(code: string, _with?: string, fields?: string, scenario?: string, options?: any) {
        return CountryApiFp(this.configuration).countriesCodeGet(code, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update Country
     * @summary Update the specified Country in storage
     * @param {} code Country code
     * @param {} [body] Country that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countriesCodePut(code: string, body?: NewCountry, options?: any) {
        return CountryApiFp(this.configuration).countriesCodePut(code, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Countries
     * @summary Get a listing of the Countries.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [enabled] Enabled
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countriesGet(offset: number, limit: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return CountryApiFp(this.configuration).countriesGet(offset, limit, search, sort_order, enabled, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Countries
     * @summary Get a listing of the Countries.
     * @param {} locale Country locale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countriesListGet(locale: 'ru' | 'en', options?: any) {
        return CountryApiFp(this.configuration).countriesListGet(locale, options)(this.fetch, this.basePath);
    }

    /**
     * Store Country
     * @summary Store a newly created Country in storage
     * @param {} [body] Country that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countriesPost(body?: Country, options?: any) {
        return CountryApiFp(this.configuration).countriesPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * DiscountApi - fetch parameter creator
 * @export
 */
export const DiscountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all Discount
         * @summary Get a listing of the Discount.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling discountsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling discountsGet.');
            }
            const localVarPath = `/discounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Discount
         * @summary Remove the specified Discount from storage
         * @param {number} id id of Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling discountsIdDelete.');
            }
            const localVarPath = `/discounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Discount
         * @summary Display the specified Discount
         * @param {number} id id of Discount
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling discountsIdGet.');
            }
            const localVarPath = `/discounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Discount
         * @summary Update the specified Discount in storage
         * @param {number} id id of Discount
         * @param {UpdateDiscount} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdPut(id: number, body?: UpdateDiscount, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling discountsIdPut.');
            }
            const localVarPath = `/discounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateDiscount" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change Discount State
         * @summary Change Discount state
         * @param {number} id id of Discount
         * @param {UpdateDiscountState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdStatePut(id: number, body?: UpdateDiscountState, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling discountsIdStatePut.');
            }
            const localVarPath = `/discounts/{id}/state`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateDiscountState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store Discount
         * @summary Store a newly created Discount in storage
         * @param {NewDiscount} [body] Discount that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsPost(body?: NewDiscount, options: any = {}): FetchArgs {
            const localVarPath = `/discounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewDiscount" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscountApi - functional programming interface
 * @export
 */
export const DiscountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all Discount
         * @summary Get a listing of the Discount.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = DiscountApiFetchParamCreator(configuration).discountsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete Discount
         * @summary Remove the specified Discount from storage
         * @param {number} id id of Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = DiscountApiFetchParamCreator(configuration).discountsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Discount
         * @summary Display the specified Discount
         * @param {number} id id of Discount
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = DiscountApiFetchParamCreator(configuration).discountsIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Discount
         * @summary Update the specified Discount in storage
         * @param {number} id id of Discount
         * @param {UpdateDiscount} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdPut(id: number, body?: UpdateDiscount, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = DiscountApiFetchParamCreator(configuration).discountsIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change Discount State
         * @summary Change Discount state
         * @param {number} id id of Discount
         * @param {UpdateDiscountState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdStatePut(id: number, body?: UpdateDiscountState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = DiscountApiFetchParamCreator(configuration).discountsIdStatePut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store Discount
         * @summary Store a newly created Discount in storage
         * @param {NewDiscount} [body] Discount that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsPost(body?: NewDiscount, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = DiscountApiFetchParamCreator(configuration).discountsPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DiscountApi - factory interface
 * @export
 */
export const DiscountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all Discount
         * @summary Get a listing of the Discount.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return DiscountApiFp(configuration).discountsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Delete Discount
         * @summary Remove the specified Discount from storage
         * @param {number} id id of Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdDelete(id: number, options?: any) {
            return DiscountApiFp(configuration).discountsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get Discount
         * @summary Display the specified Discount
         * @param {number} id id of Discount
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return DiscountApiFp(configuration).discountsIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update Discount
         * @summary Update the specified Discount in storage
         * @param {number} id id of Discount
         * @param {UpdateDiscount} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdPut(id: number, body?: UpdateDiscount, options?: any) {
            return DiscountApiFp(configuration).discountsIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Change Discount State
         * @summary Change Discount state
         * @param {number} id id of Discount
         * @param {UpdateDiscountState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsIdStatePut(id: number, body?: UpdateDiscountState, options?: any) {
            return DiscountApiFp(configuration).discountsIdStatePut(id, body, options)(fetch, basePath);
        },
        /**
         * Store Discount
         * @summary Store a newly created Discount in storage
         * @param {NewDiscount} [body] Discount that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsPost(body?: NewDiscount, options?: any) {
            return DiscountApiFp(configuration).discountsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * DiscountApi - object-oriented interface
 * @export
 * @class DiscountApi
 * @extends {BaseAPI}
 */
export class DiscountApi extends BaseAPI {
    /**
     * Get all Discount
     * @summary Get a listing of the Discount.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public discountsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return DiscountApiFp(this.configuration).discountsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Delete Discount
     * @summary Remove the specified Discount from storage
     * @param {} id id of Discount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public discountsIdDelete(id: number, options?: any) {
        return DiscountApiFp(this.configuration).discountsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get Discount
     * @summary Display the specified Discount
     * @param {} id id of Discount
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public discountsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return DiscountApiFp(this.configuration).discountsIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update Discount
     * @summary Update the specified Discount in storage
     * @param {} id id of Discount
     * @param {} [body] Discount that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public discountsIdPut(id: number, body?: UpdateDiscount, options?: any) {
        return DiscountApiFp(this.configuration).discountsIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Change Discount State
     * @summary Change Discount state
     * @param {} id id of Discount
     * @param {} [body] Discount that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public discountsIdStatePut(id: number, body?: UpdateDiscountState, options?: any) {
        return DiscountApiFp(this.configuration).discountsIdStatePut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store Discount
     * @summary Store a newly created Discount in storage
     * @param {} [body] Discount that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public discountsPost(body?: NewDiscount, options?: any) {
        return DiscountApiFp(this.configuration).discountsPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * DocumentApi - fetch parameter creator
 * @export
 */
export const DocumentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all Documents
         * @summary Get a listing of the Documents.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {string} [type] Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling documentsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling documentsGet.');
            }
            const localVarPath = `/documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Document
         * @summary Remove the specified Document from storage
         * @param {number} id id of Document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling documentsIdDelete.');
            }
            const localVarPath = `/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Document
         * @summary Display the specified Document
         * @param {number} id id of Document
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling documentsIdGet.');
            }
            const localVarPath = `/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Document
         * @summary Update the specified Document in storage
         * @param {number} id id of Document
         * @param {NewDocument} [body] Document that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdPut(id: number, body?: NewDocument, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling documentsIdPut.');
            }
            const localVarPath = `/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewDocument" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change Document State
         * @summary Change Document state
         * @param {number} id id of Document
         * @param {UpdateDocumentState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdStatePut(id: number, body?: UpdateDocumentState, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling documentsIdStatePut.');
            }
            const localVarPath = `/documents/{id}/state`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateDocumentState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store Document
         * @summary Store a newly created Document in storage
         * @param {NewDocument} [body] Document that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPost(body?: NewDocument, options: any = {}): FetchArgs {
            const localVarPath = `/documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewDocument" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all Documents
         * @summary Get a listing of the Documents.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {string} [type] Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).documentsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete Document
         * @summary Remove the specified Document from storage
         * @param {number} id id of Document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).documentsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Document
         * @summary Display the specified Document
         * @param {number} id id of Document
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).documentsIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Document
         * @summary Update the specified Document in storage
         * @param {number} id id of Document
         * @param {NewDocument} [body] Document that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdPut(id: number, body?: NewDocument, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).documentsIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change Document State
         * @summary Change Document state
         * @param {number} id id of Document
         * @param {UpdateDocumentState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdStatePut(id: number, body?: UpdateDocumentState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).documentsIdStatePut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store Document
         * @summary Store a newly created Document in storage
         * @param {NewDocument} [body] Document that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPost(body?: NewDocument, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).documentsPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all Documents
         * @summary Get a listing of the Documents.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {string} [type] Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, type?: string, options?: any) {
            return DocumentApiFp(configuration).documentsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, type, options)(fetch, basePath);
        },
        /**
         * Delete Document
         * @summary Remove the specified Document from storage
         * @param {number} id id of Document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdDelete(id: number, options?: any) {
            return DocumentApiFp(configuration).documentsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get Document
         * @summary Display the specified Document
         * @param {number} id id of Document
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return DocumentApiFp(configuration).documentsIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update Document
         * @summary Update the specified Document in storage
         * @param {number} id id of Document
         * @param {NewDocument} [body] Document that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdPut(id: number, body?: NewDocument, options?: any) {
            return DocumentApiFp(configuration).documentsIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Change Document State
         * @summary Change Document state
         * @param {number} id id of Document
         * @param {UpdateDocumentState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIdStatePut(id: number, body?: UpdateDocumentState, options?: any) {
            return DocumentApiFp(configuration).documentsIdStatePut(id, body, options)(fetch, basePath);
        },
        /**
         * Store Document
         * @summary Store a newly created Document in storage
         * @param {NewDocument} [body] Document that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPost(body?: NewDocument, options?: any) {
            return DocumentApiFp(configuration).documentsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * Get all Documents
     * @summary Get a listing of the Documents.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {} [type] Type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, type?: string, options?: any) {
        return DocumentApiFp(this.configuration).documentsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, type, options)(this.fetch, this.basePath);
    }

    /**
     * Delete Document
     * @summary Remove the specified Document from storage
     * @param {} id id of Document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentsIdDelete(id: number, options?: any) {
        return DocumentApiFp(this.configuration).documentsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get Document
     * @summary Display the specified Document
     * @param {} id id of Document
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return DocumentApiFp(this.configuration).documentsIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update Document
     * @summary Update the specified Document in storage
     * @param {} id id of Document
     * @param {} [body] Document that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentsIdPut(id: number, body?: NewDocument, options?: any) {
        return DocumentApiFp(this.configuration).documentsIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Change Document State
     * @summary Change Document state
     * @param {} id id of Document
     * @param {} [body] Discount that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentsIdStatePut(id: number, body?: UpdateDocumentState, options?: any) {
        return DocumentApiFp(this.configuration).documentsIdStatePut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store Document
     * @summary Store a newly created Document in storage
     * @param {} [body] Document that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentsPost(body?: NewDocument, options?: any) {
        return DocumentApiFp(this.configuration).documentsPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * EvaluationsQuestionApi - fetch parameter creator
 * @export
 */
export const EvaluationsQuestionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all EvaluationsQuestion
         * @summary Get a listing of the EvaluationsQuestion.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling evaluationQuestionsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling evaluationQuestionsGet.');
            }
            const localVarPath = `/evaluation-questions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete EvaluationsQuestion
         * @summary Remove the specified EvaluationsQuestion from storage
         * @param {number} id id of EvaluationsQuestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling evaluationQuestionsIdDelete.');
            }
            const localVarPath = `/evaluation-questions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get EvaluationsQuestion
         * @summary Display the specified EvaluationsQuestion
         * @param {number} id id of EvaluationsQuestion
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling evaluationQuestionsIdGet.');
            }
            const localVarPath = `/evaluation-questions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update EvaluationsQuestion
         * @summary Update the specified EvaluationsQuestion in storage
         * @param {number} id id of EvaluationsQuestion
         * @param {NewEvaluationsQuestion} [body] EvaluationsQuestion that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsIdPut(id: number, body?: NewEvaluationsQuestion, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling evaluationQuestionsIdPut.');
            }
            const localVarPath = `/evaluation-questions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewEvaluationsQuestion" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store EvaluationsQuestion
         * @summary Store a newly created EvaluationsQuestion in storage
         * @param {NewEvaluationsQuestion} [body] EvaluationsQuestion that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsPost(body?: NewEvaluationsQuestion, options: any = {}): FetchArgs {
            const localVarPath = `/evaluation-questions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewEvaluationsQuestion" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EvaluationsQuestionApi - functional programming interface
 * @export
 */
export const EvaluationsQuestionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all EvaluationsQuestion
         * @summary Get a listing of the EvaluationsQuestion.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = EvaluationsQuestionApiFetchParamCreator(configuration).evaluationQuestionsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete EvaluationsQuestion
         * @summary Remove the specified EvaluationsQuestion from storage
         * @param {number} id id of EvaluationsQuestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = EvaluationsQuestionApiFetchParamCreator(configuration).evaluationQuestionsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get EvaluationsQuestion
         * @summary Display the specified EvaluationsQuestion
         * @param {number} id id of EvaluationsQuestion
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = EvaluationsQuestionApiFetchParamCreator(configuration).evaluationQuestionsIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update EvaluationsQuestion
         * @summary Update the specified EvaluationsQuestion in storage
         * @param {number} id id of EvaluationsQuestion
         * @param {NewEvaluationsQuestion} [body] EvaluationsQuestion that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsIdPut(id: number, body?: NewEvaluationsQuestion, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = EvaluationsQuestionApiFetchParamCreator(configuration).evaluationQuestionsIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store EvaluationsQuestion
         * @summary Store a newly created EvaluationsQuestion in storage
         * @param {NewEvaluationsQuestion} [body] EvaluationsQuestion that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsPost(body?: NewEvaluationsQuestion, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = EvaluationsQuestionApiFetchParamCreator(configuration).evaluationQuestionsPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EvaluationsQuestionApi - factory interface
 * @export
 */
export const EvaluationsQuestionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all EvaluationsQuestion
         * @summary Get a listing of the EvaluationsQuestion.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return EvaluationsQuestionApiFp(configuration).evaluationQuestionsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Delete EvaluationsQuestion
         * @summary Remove the specified EvaluationsQuestion from storage
         * @param {number} id id of EvaluationsQuestion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsIdDelete(id: number, options?: any) {
            return EvaluationsQuestionApiFp(configuration).evaluationQuestionsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get EvaluationsQuestion
         * @summary Display the specified EvaluationsQuestion
         * @param {number} id id of EvaluationsQuestion
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return EvaluationsQuestionApiFp(configuration).evaluationQuestionsIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update EvaluationsQuestion
         * @summary Update the specified EvaluationsQuestion in storage
         * @param {number} id id of EvaluationsQuestion
         * @param {NewEvaluationsQuestion} [body] EvaluationsQuestion that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsIdPut(id: number, body?: NewEvaluationsQuestion, options?: any) {
            return EvaluationsQuestionApiFp(configuration).evaluationQuestionsIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Store EvaluationsQuestion
         * @summary Store a newly created EvaluationsQuestion in storage
         * @param {NewEvaluationsQuestion} [body] EvaluationsQuestion that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluationQuestionsPost(body?: NewEvaluationsQuestion, options?: any) {
            return EvaluationsQuestionApiFp(configuration).evaluationQuestionsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * EvaluationsQuestionApi - object-oriented interface
 * @export
 * @class EvaluationsQuestionApi
 * @extends {BaseAPI}
 */
export class EvaluationsQuestionApi extends BaseAPI {
    /**
     * Get all EvaluationsQuestion
     * @summary Get a listing of the EvaluationsQuestion.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsQuestionApi
     */
    public evaluationQuestionsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return EvaluationsQuestionApiFp(this.configuration).evaluationQuestionsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Delete EvaluationsQuestion
     * @summary Remove the specified EvaluationsQuestion from storage
     * @param {} id id of EvaluationsQuestion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsQuestionApi
     */
    public evaluationQuestionsIdDelete(id: number, options?: any) {
        return EvaluationsQuestionApiFp(this.configuration).evaluationQuestionsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get EvaluationsQuestion
     * @summary Display the specified EvaluationsQuestion
     * @param {} id id of EvaluationsQuestion
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsQuestionApi
     */
    public evaluationQuestionsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return EvaluationsQuestionApiFp(this.configuration).evaluationQuestionsIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update EvaluationsQuestion
     * @summary Update the specified EvaluationsQuestion in storage
     * @param {} id id of EvaluationsQuestion
     * @param {} [body] EvaluationsQuestion that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsQuestionApi
     */
    public evaluationQuestionsIdPut(id: number, body?: NewEvaluationsQuestion, options?: any) {
        return EvaluationsQuestionApiFp(this.configuration).evaluationQuestionsIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store EvaluationsQuestion
     * @summary Store a newly created EvaluationsQuestion in storage
     * @param {} [body] EvaluationsQuestion that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvaluationsQuestionApi
     */
    public evaluationQuestionsPost(body?: NewEvaluationsQuestion, options?: any) {
        return EvaluationsQuestionApiFp(this.configuration).evaluationQuestionsPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * LessonApi - fetch parameter creator
 * @export
 */
export const LessonApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all Lessons
         * @summary Get a listing of the Lessons.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling lessonsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling lessonsGet.');
            }
            const localVarPath = `/lessons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Lesson
         * @summary Remove the specified Lesson from storage
         * @param {number} id id of Lesson
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling lessonsIdDelete.');
            }
            const localVarPath = `/lessons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Lesson
         * @summary Display the specified Lesson
         * @param {number} id id of Lesson
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling lessonsIdGet.');
            }
            const localVarPath = `/lessons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all LessonsMarker
         * @summary Get a listing of the LessonsMarker.
         * @param {number} id Lesson ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling lessonsIdMarkersGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling lessonsIdMarkersGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling lessonsIdMarkersGet.');
            }
            const localVarPath = `/lessons/{id}/markers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete LessonsMarker
         * @summary Remove the specified LessonsMarker from storage
         * @param {number} id id of Lesson
         * @param {string} markerCode Marker Code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersMarkerCodeDelete(id: number, markerCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling lessonsIdMarkersMarkerCodeDelete.');
            }
            // verify required parameter 'markerCode' is not null or undefined
            if (markerCode === null || markerCode === undefined) {
                throw new RequiredError('markerCode','Required parameter markerCode was null or undefined when calling lessonsIdMarkersMarkerCodeDelete.');
            }
            const localVarPath = `/lessons/{id}/markers/{markerCode}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"markerCode"}}`, encodeURIComponent(String(markerCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get LessonsMarker
         * @summary Display the specified LessonsMarker
         * @param {number} id id of Lesson
         * @param {string} markerCode Marker Code
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersMarkerCodeGet(id: number, markerCode: string, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling lessonsIdMarkersMarkerCodeGet.');
            }
            // verify required parameter 'markerCode' is not null or undefined
            if (markerCode === null || markerCode === undefined) {
                throw new RequiredError('markerCode','Required parameter markerCode was null or undefined when calling lessonsIdMarkersMarkerCodeGet.');
            }
            const localVarPath = `/lessons/{id}/markers/{markerCode}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"markerCode"}}`, encodeURIComponent(String(markerCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update LessonsMarker
         * @summary Update the specified LessonsMarker in storage
         * @param {number} id id of Lesson
         * @param {string} markerCode Marker Code
         * @param {UpdateLessonsMarker} [body] LessonsMarker that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersMarkerCodePut(id: number, markerCode: string, body?: UpdateLessonsMarker, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling lessonsIdMarkersMarkerCodePut.');
            }
            // verify required parameter 'markerCode' is not null or undefined
            if (markerCode === null || markerCode === undefined) {
                throw new RequiredError('markerCode','Required parameter markerCode was null or undefined when calling lessonsIdMarkersMarkerCodePut.');
            }
            const localVarPath = `/lessons/{id}/markers/{markerCode}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"markerCode"}}`, encodeURIComponent(String(markerCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateLessonsMarker" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store LessonsMarker
         * @summary Store a newly created LessonsMarker in storage
         * @param {number} id id of Lesson
         * @param {NewLessonsMarker} [body] LessonsMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersPost(id: number, body?: NewLessonsMarker, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling lessonsIdMarkersPost.');
            }
            const localVarPath = `/lessons/{id}/markers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewLessonsMarker" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Lesson
         * @summary Update the specified Lesson in storage
         * @param {number} id id of Lesson
         * @param {NewLesson} [body] Lesson that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdPut(id: number, body?: NewLesson, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling lessonsIdPut.');
            }
            const localVarPath = `/lessons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewLesson" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change Lesson State
         * @summary Change Lesson state
         * @param {number} lesson_id Lesson ID
         * @param {Lesson} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdStatePut(lesson_id: number, body?: Lesson, options: any = {}): FetchArgs {
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling lessonsIdStatePut.');
            }
            const localVarPath = `/lessons/{id}/state`
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Lesson" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all reschedules
         * @summary Get a listing of the LessonsReschedule.
         * @param {number} lesson_id Lesson ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesGet(lesson_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling lessonsLessonIdReschedulesGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling lessonsLessonIdReschedulesGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling lessonsLessonIdReschedulesGet.');
            }
            const localVarPath = `/lessons/{lesson_id}/reschedules`
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store lesson reschedule
         * @summary Store a newly created lesson reschedules in storage
         * @param {number} lesson_id Lesson ID
         * @param {NewLessonsReschedule} [body] NewLessonsReschedule that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesPost(lesson_id: number, body?: NewLessonsReschedule, options: any = {}): FetchArgs {
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling lessonsLessonIdReschedulesPost.');
            }
            const localVarPath = `/lessons/{lesson_id}/reschedules`
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewLessonsReschedule" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete LessonsReschedule
         * @summary Delete the specified LessonsReschedule in storage
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdDelete(lesson_id: number, reschedule_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling lessonsLessonIdReschedulesRescheduleIdDelete.');
            }
            // verify required parameter 'reschedule_id' is not null or undefined
            if (reschedule_id === null || reschedule_id === undefined) {
                throw new RequiredError('reschedule_id','Required parameter reschedule_id was null or undefined when calling lessonsLessonIdReschedulesRescheduleIdDelete.');
            }
            const localVarPath = `/lessons/{lesson_id}/reschedules/{reschedule_id}`
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)))
                .replace(`{${"reschedule_id"}}`, encodeURIComponent(String(reschedule_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Lesson Reschedule
         * @summary Display the specified Lessons reschedule
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdGet(lesson_id: number, reschedule_id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling lessonsLessonIdReschedulesRescheduleIdGet.');
            }
            // verify required parameter 'reschedule_id' is not null or undefined
            if (reschedule_id === null || reschedule_id === undefined) {
                throw new RequiredError('reschedule_id','Required parameter reschedule_id was null or undefined when calling lessonsLessonIdReschedulesRescheduleIdGet.');
            }
            const localVarPath = `/lessons/{lesson_id}/reschedules/{reschedule_id}`
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)))
                .replace(`{${"reschedule_id"}}`, encodeURIComponent(String(reschedule_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update LessonsReschedule
         * @summary Update the specified LessonsReschedule in storage
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {UpdateLessonsReschedule} [body] UpdateLessonsReschedule that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdPut(lesson_id: number, reschedule_id: number, body?: UpdateLessonsReschedule, options: any = {}): FetchArgs {
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling lessonsLessonIdReschedulesRescheduleIdPut.');
            }
            // verify required parameter 'reschedule_id' is not null or undefined
            if (reschedule_id === null || reschedule_id === undefined) {
                throw new RequiredError('reschedule_id','Required parameter reschedule_id was null or undefined when calling lessonsLessonIdReschedulesRescheduleIdPut.');
            }
            const localVarPath = `/lessons/{lesson_id}/reschedules/{reschedule_id}`
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)))
                .replace(`{${"reschedule_id"}}`, encodeURIComponent(String(reschedule_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateLessonsReschedule" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change LessonsReschedule State
         * @summary Change LessonsReschedule state
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {LessonsReschedule} [body] LessonsReschedule that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdStatePut(lesson_id: number, reschedule_id: number, body?: LessonsReschedule, options: any = {}): FetchArgs {
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling lessonsLessonIdReschedulesRescheduleIdStatePut.');
            }
            // verify required parameter 'reschedule_id' is not null or undefined
            if (reschedule_id === null || reschedule_id === undefined) {
                throw new RequiredError('reschedule_id','Required parameter reschedule_id was null or undefined when calling lessonsLessonIdReschedulesRescheduleIdStatePut.');
            }
            const localVarPath = `/lessons/{lesson_id}/reschedules/{reschedule_id}/state`
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)))
                .replace(`{${"reschedule_id"}}`, encodeURIComponent(String(reschedule_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LessonsReschedule" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change LessonsReschedule State
         * @summary Change many LessonsReschedule state
         * @param {ManyLessonsReschedule} [body] LessonsReschedule that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsManyReschedulePut(body?: ManyLessonsReschedule, options: any = {}): FetchArgs {
            const localVarPath = `/lessons/many-reschedule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ManyLessonsReschedule" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store Lesson
         * @summary Store a newly created Lesson in storage
         * @param {NewLesson} [body] Lesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsPost(body?: NewLesson, options: any = {}): FetchArgs {
            const localVarPath = `/lessons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewLesson" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LessonApi - functional programming interface
 * @export
 */
export const LessonApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all Lessons
         * @summary Get a listing of the Lessons.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete Lesson
         * @summary Remove the specified Lesson from storage
         * @param {number} id id of Lesson
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Lesson
         * @summary Display the specified Lesson
         * @param {number} id id of Lesson
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all LessonsMarker
         * @summary Get a listing of the LessonsMarker.
         * @param {number} id Lesson ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsIdMarkersGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete LessonsMarker
         * @summary Remove the specified LessonsMarker from storage
         * @param {number} id id of Lesson
         * @param {string} markerCode Marker Code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersMarkerCodeDelete(id: number, markerCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsIdMarkersMarkerCodeDelete(id, markerCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get LessonsMarker
         * @summary Display the specified LessonsMarker
         * @param {number} id id of Lesson
         * @param {string} markerCode Marker Code
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersMarkerCodeGet(id: number, markerCode: string, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20017> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsIdMarkersMarkerCodeGet(id, markerCode, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update LessonsMarker
         * @summary Update the specified LessonsMarker in storage
         * @param {number} id id of Lesson
         * @param {string} markerCode Marker Code
         * @param {UpdateLessonsMarker} [body] LessonsMarker that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersMarkerCodePut(id: number, markerCode: string, body?: UpdateLessonsMarker, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20017> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsIdMarkersMarkerCodePut(id, markerCode, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store LessonsMarker
         * @summary Store a newly created LessonsMarker in storage
         * @param {number} id id of Lesson
         * @param {NewLessonsMarker} [body] LessonsMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersPost(id: number, body?: NewLessonsMarker, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20017> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsIdMarkersPost(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Lesson
         * @summary Update the specified Lesson in storage
         * @param {number} id id of Lesson
         * @param {NewLesson} [body] Lesson that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdPut(id: number, body?: NewLesson, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change Lesson State
         * @summary Change Lesson state
         * @param {number} lesson_id Lesson ID
         * @param {Lesson} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdStatePut(lesson_id: number, body?: Lesson, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsIdStatePut(lesson_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all reschedules
         * @summary Get a listing of the LessonsReschedule.
         * @param {number} lesson_id Lesson ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesGet(lesson_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20018> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsLessonIdReschedulesGet(lesson_id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store lesson reschedule
         * @summary Store a newly created lesson reschedules in storage
         * @param {number} lesson_id Lesson ID
         * @param {NewLessonsReschedule} [body] NewLessonsReschedule that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesPost(lesson_id: number, body?: NewLessonsReschedule, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20019> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsLessonIdReschedulesPost(lesson_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete LessonsReschedule
         * @summary Delete the specified LessonsReschedule in storage
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdDelete(lesson_id: number, reschedule_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsLessonIdReschedulesRescheduleIdDelete(lesson_id, reschedule_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Lesson Reschedule
         * @summary Display the specified Lessons reschedule
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdGet(lesson_id: number, reschedule_id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsLessonIdReschedulesRescheduleIdGet(lesson_id, reschedule_id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update LessonsReschedule
         * @summary Update the specified LessonsReschedule in storage
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {UpdateLessonsReschedule} [body] UpdateLessonsReschedule that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdPut(lesson_id: number, reschedule_id: number, body?: UpdateLessonsReschedule, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsLessonIdReschedulesRescheduleIdPut(lesson_id, reschedule_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change LessonsReschedule State
         * @summary Change LessonsReschedule state
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {LessonsReschedule} [body] LessonsReschedule that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdStatePut(lesson_id: number, reschedule_id: number, body?: LessonsReschedule, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsLessonIdReschedulesRescheduleIdStatePut(lesson_id, reschedule_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change LessonsReschedule State
         * @summary Change many LessonsReschedule state
         * @param {ManyLessonsReschedule} [body] LessonsReschedule that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsManyReschedulePut(body?: ManyLessonsReschedule, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsManyReschedulePut(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store Lesson
         * @summary Store a newly created Lesson in storage
         * @param {NewLesson} [body] Lesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsPost(body?: NewLesson, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = LessonApiFetchParamCreator(configuration).lessonsPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LessonApi - factory interface
 * @export
 */
export const LessonApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all Lessons
         * @summary Get a listing of the Lessons.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return LessonApiFp(configuration).lessonsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Delete Lesson
         * @summary Remove the specified Lesson from storage
         * @param {number} id id of Lesson
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdDelete(id: number, options?: any) {
            return LessonApiFp(configuration).lessonsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get Lesson
         * @summary Display the specified Lesson
         * @param {number} id id of Lesson
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return LessonApiFp(configuration).lessonsIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get all LessonsMarker
         * @summary Get a listing of the LessonsMarker.
         * @param {number} id Lesson ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return LessonApiFp(configuration).lessonsIdMarkersGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Delete LessonsMarker
         * @summary Remove the specified LessonsMarker from storage
         * @param {number} id id of Lesson
         * @param {string} markerCode Marker Code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersMarkerCodeDelete(id: number, markerCode: string, options?: any) {
            return LessonApiFp(configuration).lessonsIdMarkersMarkerCodeDelete(id, markerCode, options)(fetch, basePath);
        },
        /**
         * Get LessonsMarker
         * @summary Display the specified LessonsMarker
         * @param {number} id id of Lesson
         * @param {string} markerCode Marker Code
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersMarkerCodeGet(id: number, markerCode: string, _with?: string, fields?: string, scenario?: string, options?: any) {
            return LessonApiFp(configuration).lessonsIdMarkersMarkerCodeGet(id, markerCode, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update LessonsMarker
         * @summary Update the specified LessonsMarker in storage
         * @param {number} id id of Lesson
         * @param {string} markerCode Marker Code
         * @param {UpdateLessonsMarker} [body] LessonsMarker that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersMarkerCodePut(id: number, markerCode: string, body?: UpdateLessonsMarker, options?: any) {
            return LessonApiFp(configuration).lessonsIdMarkersMarkerCodePut(id, markerCode, body, options)(fetch, basePath);
        },
        /**
         * Store LessonsMarker
         * @summary Store a newly created LessonsMarker in storage
         * @param {number} id id of Lesson
         * @param {NewLessonsMarker} [body] LessonsMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdMarkersPost(id: number, body?: NewLessonsMarker, options?: any) {
            return LessonApiFp(configuration).lessonsIdMarkersPost(id, body, options)(fetch, basePath);
        },
        /**
         * Update Lesson
         * @summary Update the specified Lesson in storage
         * @param {number} id id of Lesson
         * @param {NewLesson} [body] Lesson that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdPut(id: number, body?: NewLesson, options?: any) {
            return LessonApiFp(configuration).lessonsIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Change Lesson State
         * @summary Change Lesson state
         * @param {number} lesson_id Lesson ID
         * @param {Lesson} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsIdStatePut(lesson_id: number, body?: Lesson, options?: any) {
            return LessonApiFp(configuration).lessonsIdStatePut(lesson_id, body, options)(fetch, basePath);
        },
        /**
         * Get all reschedules
         * @summary Get a listing of the LessonsReschedule.
         * @param {number} lesson_id Lesson ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesGet(lesson_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return LessonApiFp(configuration).lessonsLessonIdReschedulesGet(lesson_id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Store lesson reschedule
         * @summary Store a newly created lesson reschedules in storage
         * @param {number} lesson_id Lesson ID
         * @param {NewLessonsReschedule} [body] NewLessonsReschedule that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesPost(lesson_id: number, body?: NewLessonsReschedule, options?: any) {
            return LessonApiFp(configuration).lessonsLessonIdReschedulesPost(lesson_id, body, options)(fetch, basePath);
        },
        /**
         * Delete LessonsReschedule
         * @summary Delete the specified LessonsReschedule in storage
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdDelete(lesson_id: number, reschedule_id: number, options?: any) {
            return LessonApiFp(configuration).lessonsLessonIdReschedulesRescheduleIdDelete(lesson_id, reschedule_id, options)(fetch, basePath);
        },
        /**
         * Get Lesson Reschedule
         * @summary Display the specified Lessons reschedule
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdGet(lesson_id: number, reschedule_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return LessonApiFp(configuration).lessonsLessonIdReschedulesRescheduleIdGet(lesson_id, reschedule_id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update LessonsReschedule
         * @summary Update the specified LessonsReschedule in storage
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {UpdateLessonsReschedule} [body] UpdateLessonsReschedule that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdPut(lesson_id: number, reschedule_id: number, body?: UpdateLessonsReschedule, options?: any) {
            return LessonApiFp(configuration).lessonsLessonIdReschedulesRescheduleIdPut(lesson_id, reschedule_id, body, options)(fetch, basePath);
        },
        /**
         * Change LessonsReschedule State
         * @summary Change LessonsReschedule state
         * @param {number} lesson_id Lesson ID
         * @param {number} reschedule_id Lesson Reschedule ID
         * @param {LessonsReschedule} [body] LessonsReschedule that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsLessonIdReschedulesRescheduleIdStatePut(lesson_id: number, reschedule_id: number, body?: LessonsReschedule, options?: any) {
            return LessonApiFp(configuration).lessonsLessonIdReschedulesRescheduleIdStatePut(lesson_id, reschedule_id, body, options)(fetch, basePath);
        },
        /**
         * Change LessonsReschedule State
         * @summary Change many LessonsReschedule state
         * @param {ManyLessonsReschedule} [body] LessonsReschedule that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsManyReschedulePut(body?: ManyLessonsReschedule, options?: any) {
            return LessonApiFp(configuration).lessonsManyReschedulePut(body, options)(fetch, basePath);
        },
        /**
         * Store Lesson
         * @summary Store a newly created Lesson in storage
         * @param {NewLesson} [body] Lesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonsPost(body?: NewLesson, options?: any) {
            return LessonApiFp(configuration).lessonsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * LessonApi - object-oriented interface
 * @export
 * @class LessonApi
 * @extends {BaseAPI}
 */
export class LessonApi extends BaseAPI {
    /**
     * Get all Lessons
     * @summary Get a listing of the Lessons.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return LessonApiFp(this.configuration).lessonsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Delete Lesson
     * @summary Remove the specified Lesson from storage
     * @param {} id id of Lesson
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsIdDelete(id: number, options?: any) {
        return LessonApiFp(this.configuration).lessonsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get Lesson
     * @summary Display the specified Lesson
     * @param {} id id of Lesson
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return LessonApiFp(this.configuration).lessonsIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get all LessonsMarker
     * @summary Get a listing of the LessonsMarker.
     * @param {} id Lesson ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsIdMarkersGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return LessonApiFp(this.configuration).lessonsIdMarkersGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Delete LessonsMarker
     * @summary Remove the specified LessonsMarker from storage
     * @param {} id id of Lesson
     * @param {} markerCode Marker Code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsIdMarkersMarkerCodeDelete(id: number, markerCode: string, options?: any) {
        return LessonApiFp(this.configuration).lessonsIdMarkersMarkerCodeDelete(id, markerCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get LessonsMarker
     * @summary Display the specified LessonsMarker
     * @param {} id id of Lesson
     * @param {} markerCode Marker Code
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsIdMarkersMarkerCodeGet(id: number, markerCode: string, _with?: string, fields?: string, scenario?: string, options?: any) {
        return LessonApiFp(this.configuration).lessonsIdMarkersMarkerCodeGet(id, markerCode, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update LessonsMarker
     * @summary Update the specified LessonsMarker in storage
     * @param {} id id of Lesson
     * @param {} markerCode Marker Code
     * @param {} [body] LessonsMarker that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsIdMarkersMarkerCodePut(id: number, markerCode: string, body?: UpdateLessonsMarker, options?: any) {
        return LessonApiFp(this.configuration).lessonsIdMarkersMarkerCodePut(id, markerCode, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store LessonsMarker
     * @summary Store a newly created LessonsMarker in storage
     * @param {} id id of Lesson
     * @param {} [body] LessonsMarker that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsIdMarkersPost(id: number, body?: NewLessonsMarker, options?: any) {
        return LessonApiFp(this.configuration).lessonsIdMarkersPost(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update Lesson
     * @summary Update the specified Lesson in storage
     * @param {} id id of Lesson
     * @param {} [body] Lesson that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsIdPut(id: number, body?: NewLesson, options?: any) {
        return LessonApiFp(this.configuration).lessonsIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Change Lesson State
     * @summary Change Lesson state
     * @param {} lesson_id Lesson ID
     * @param {} [body] Discount that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsIdStatePut(lesson_id: number, body?: Lesson, options?: any) {
        return LessonApiFp(this.configuration).lessonsIdStatePut(lesson_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get all reschedules
     * @summary Get a listing of the LessonsReschedule.
     * @param {} lesson_id Lesson ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsLessonIdReschedulesGet(lesson_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return LessonApiFp(this.configuration).lessonsLessonIdReschedulesGet(lesson_id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Store lesson reschedule
     * @summary Store a newly created lesson reschedules in storage
     * @param {} lesson_id Lesson ID
     * @param {} [body] NewLessonsReschedule that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsLessonIdReschedulesPost(lesson_id: number, body?: NewLessonsReschedule, options?: any) {
        return LessonApiFp(this.configuration).lessonsLessonIdReschedulesPost(lesson_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete LessonsReschedule
     * @summary Delete the specified LessonsReschedule in storage
     * @param {} lesson_id Lesson ID
     * @param {} reschedule_id Lesson Reschedule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsLessonIdReschedulesRescheduleIdDelete(lesson_id: number, reschedule_id: number, options?: any) {
        return LessonApiFp(this.configuration).lessonsLessonIdReschedulesRescheduleIdDelete(lesson_id, reschedule_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get Lesson Reschedule
     * @summary Display the specified Lessons reschedule
     * @param {} lesson_id Lesson ID
     * @param {} reschedule_id Lesson Reschedule ID
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsLessonIdReschedulesRescheduleIdGet(lesson_id: number, reschedule_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return LessonApiFp(this.configuration).lessonsLessonIdReschedulesRescheduleIdGet(lesson_id, reschedule_id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update LessonsReschedule
     * @summary Update the specified LessonsReschedule in storage
     * @param {} lesson_id Lesson ID
     * @param {} reschedule_id Lesson Reschedule ID
     * @param {} [body] UpdateLessonsReschedule that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsLessonIdReschedulesRescheduleIdPut(lesson_id: number, reschedule_id: number, body?: UpdateLessonsReschedule, options?: any) {
        return LessonApiFp(this.configuration).lessonsLessonIdReschedulesRescheduleIdPut(lesson_id, reschedule_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Change LessonsReschedule State
     * @summary Change LessonsReschedule state
     * @param {} lesson_id Lesson ID
     * @param {} reschedule_id Lesson Reschedule ID
     * @param {} [body] LessonsReschedule that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsLessonIdReschedulesRescheduleIdStatePut(lesson_id: number, reschedule_id: number, body?: LessonsReschedule, options?: any) {
        return LessonApiFp(this.configuration).lessonsLessonIdReschedulesRescheduleIdStatePut(lesson_id, reschedule_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Change LessonsReschedule State
     * @summary Change many LessonsReschedule state
     * @param {} [body] LessonsReschedule that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsManyReschedulePut(body?: ManyLessonsReschedule, options?: any) {
        return LessonApiFp(this.configuration).lessonsManyReschedulePut(body, options)(this.fetch, this.basePath);
    }

    /**
     * Store Lesson
     * @summary Store a newly created Lesson in storage
     * @param {} [body] Lesson that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonsPost(body?: NewLesson, options?: any) {
        return LessonApiFp(this.configuration).lessonsPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * MeApi - fetch parameter creator
 * @export
 */
export const MeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all evaluation for user
         * @summary Get a listing of the UserEvaluation.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling meEvaluationsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling meEvaluationsGet.');
            }
            const localVarPath = `/me/evaluations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store UsersEvaluation
         * @summary Store a newly created user evaluation in storage
         * @param {NewUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsPost(body?: NewUsersEvaluation, options: any = {}): FetchArgs {
            const localVarPath = `/me/evaluations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersEvaluation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsersEvaluation
         * @summary Delete the specified UsersEvaluation in storage
         * @param {number} teacher_id Teacher ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsTeacherIdDelete(teacher_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'teacher_id' is not null or undefined
            if (teacher_id === null || teacher_id === undefined) {
                throw new RequiredError('teacher_id','Required parameter teacher_id was null or undefined when calling meEvaluationsTeacherIdDelete.');
            }
            const localVarPath = `/me/evaluations/{teacher_id}`
                .replace(`{${"teacher_id"}}`, encodeURIComponent(String(teacher_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersEvaluation
         * @param {number} teacher_id Teacher ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsTeacherIdGet(teacher_id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'teacher_id' is not null or undefined
            if (teacher_id === null || teacher_id === undefined) {
                throw new RequiredError('teacher_id','Required parameter teacher_id was null or undefined when calling meEvaluationsTeacherIdGet.');
            }
            const localVarPath = `/me/evaluations/{teacher_id}`
                .replace(`{${"teacher_id"}}`, encodeURIComponent(String(teacher_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UsersEvaluation
         * @summary Update the specified UsersEvaluation in storage
         * @param {number} teacher_id Teacher ID
         * @param {UpdateUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsTeacherIdPut(teacher_id: number, body?: UpdateUsersEvaluation, options: any = {}): FetchArgs {
            // verify required parameter 'teacher_id' is not null or undefined
            if (teacher_id === null || teacher_id === undefined) {
                throw new RequiredError('teacher_id','Required parameter teacher_id was null or undefined when calling meEvaluationsTeacherIdPut.');
            }
            const localVarPath = `/me/evaluations/{teacher_id}`
                .replace(`{${"teacher_id"}}`, encodeURIComponent(String(teacher_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUsersEvaluation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get auth user.
         * @summary Get auth user.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(_with?: string, scenario?: string, options: any = {}): FetchArgs {
            const localVarPath = `/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user tokens by invite code.
         * @summary Get user tokens by invite code.
         * @param {string} code Invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInitTokensGet(code: string, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling meInitTokensGet.');
            }
            const localVarPath = `/me/init-tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite user. Only admins can invite user.
         * @summary Invite user by role.
         * @param {InviteUser} inviteUser Partner email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInvitePost(inviteUser: InviteUser, options: any = {}): FetchArgs {
            // verify required parameter 'inviteUser' is not null or undefined
            if (inviteUser === null || inviteUser === undefined) {
                throw new RequiredError('inviteUser','Required parameter inviteUser was null or undefined when calling meInvitePost.');
            }
            const localVarPath = `/me/invite`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InviteUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inviteUser || {}) : (inviteUser || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite user. Only admins can invite user.
         * @summary Invite user by role.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInvitesGet(_with?: string, scenario?: string, options: any = {}): FetchArgs {
            const localVarPath = `/me/invites`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get actual invoice for partner
         * @summary Generate actual invoice for partner
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInvoiceStateGet(scenario?: string, options: any = {}): FetchArgs {
            const localVarPath = `/me/invoice/state`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user messages.
         * @summary Get user messages.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {number} [recipient_id] Recipient Id.
         * @param {number} [user_id] User Id.
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {boolean} [enabled] Enabled
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesGet(offset: number, limit: number, recipient_id?: number, user_id?: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', fields?: string, _with?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling meMessagesGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling meMessagesGet.');
            }
            const localVarPath = `/me/messages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (recipient_id !== undefined) {
                localVarQueryParameter['recipient_id'] = recipient_id;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get messages history.
         * @summary Get messages history.
         * @param {number} [recipient_id] History with concrete user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesHistoryGet(recipient_id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/me/messages/history`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (recipient_id !== undefined) {
                localVarQueryParameter['recipient_id'] = recipient_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create user messages.
         * @summary Create user messages.
         * @param {NewMessage} [body] Lesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesPost(body?: NewMessage, options: any = {}): FetchArgs {
            const localVarPath = `/me/messages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark messages as read.
         * @summary Mark messages as read.
         * @param {ReadMessages} [body] Message ids array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesReadPut(body?: ReadMessages, options: any = {}): FetchArgs {
            const localVarPath = `/me/messages/read`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReadMessages" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change password.
         * @summary Change password
         * @param {PasswordReset} email Users email for password reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordChangePost(email: PasswordReset, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling mePasswordChangePost.');
            }
            const localVarPath = `/me/password/change`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordReset" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email || {}) : (email || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send email to user for password reset.
         * @summary Send email to user for password reset.
         * @param {GetTokenForPasswordReset} email Users email for password reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordEmailPost(email: GetTokenForPasswordReset, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling mePasswordEmailPost.');
            }
            const localVarPath = `/me/password/email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetTokenForPasswordReset" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email || {}) : (email || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users quiz.
         * @summary Get users quiz.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meQuizGet(_with?: string, scenario?: string, options: any = {}): FetchArgs {
            const localVarPath = `/me/quiz`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users relations.
         * @summary Get users relations.
         * @param {&#39;ADMIN&#39; | &#39;PARTNER&#39; | &#39;STUDENT&#39; | &#39;TEACHER&#39;} [type] Type of relations.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meRelationsGet(type?: 'ADMIN' | 'PARTNER' | 'STUDENT' | 'TEACHER', _with?: string, scenario?: string, options: any = {}): FetchArgs {
            const localVarPath = `/me/relations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users transactions.
         * @summary Get users transactions.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meTransactionsGet(_with?: string, options: any = {}): FetchArgs {
            const localVarPath = `/me/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login by user. Only admins can logging by user
         * @summary Login by user.
         * @param {number} user_id User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meUserTokensGet(user_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling meUserTokensGet.');
            }
            const localVarPath = `/me/user-tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all evaluation for user
         * @summary Get a listing of the UserEvaluation.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20048> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meEvaluationsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store UsersEvaluation
         * @summary Store a newly created user evaluation in storage
         * @param {NewUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsPost(body?: NewUsersEvaluation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20049> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meEvaluationsPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UsersEvaluation
         * @summary Delete the specified UsersEvaluation in storage
         * @param {number} teacher_id Teacher ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsTeacherIdDelete(teacher_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meEvaluationsTeacherIdDelete(teacher_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersEvaluation
         * @param {number} teacher_id Teacher ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsTeacherIdGet(teacher_id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20049> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meEvaluationsTeacherIdGet(teacher_id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update UsersEvaluation
         * @summary Update the specified UsersEvaluation in storage
         * @param {number} teacher_id Teacher ID
         * @param {UpdateUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsTeacherIdPut(teacher_id: number, body?: UpdateUsersEvaluation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20050> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meEvaluationsTeacherIdPut(teacher_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get auth user.
         * @summary Get auth user.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(_with?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meGet(_with, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get user tokens by invite code.
         * @summary Get user tokens by invite code.
         * @param {string} code Invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInitTokensGet(code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meInitTokensGet(code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Invite user. Only admins can invite user.
         * @summary Invite user by role.
         * @param {InviteUser} inviteUser Partner email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInvitePost(inviteUser: InviteUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meInvitePost(inviteUser, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Invite user. Only admins can invite user.
         * @summary Invite user by role.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInvitesGet(_with?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meInvitesGet(_with, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get actual invoice for partner
         * @summary Generate actual invoice for partner
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInvoiceStateGet(scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20047> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meInvoiceStateGet(scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get user messages.
         * @summary Get user messages.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {number} [recipient_id] Recipient Id.
         * @param {number} [user_id] User Id.
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {boolean} [enabled] Enabled
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesGet(offset: number, limit: number, recipient_id?: number, user_id?: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', fields?: string, _with?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meMessagesGet(offset, limit, recipient_id, user_id, search, sort_order, enabled, asc, fields, _with, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get messages history.
         * @summary Get messages history.
         * @param {number} [recipient_id] History with concrete user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesHistoryGet(recipient_id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meMessagesHistoryGet(recipient_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create user messages.
         * @summary Create user messages.
         * @param {NewMessage} [body] Lesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesPost(body?: NewMessage, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meMessagesPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Mark messages as read.
         * @summary Mark messages as read.
         * @param {ReadMessages} [body] Message ids array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesReadPut(body?: ReadMessages, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meMessagesReadPut(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change password.
         * @summary Change password
         * @param {PasswordReset} email Users email for password reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordChangePost(email: PasswordReset, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).mePasswordChangePost(email, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send email to user for password reset.
         * @summary Send email to user for password reset.
         * @param {GetTokenForPasswordReset} email Users email for password reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordEmailPost(email: GetTokenForPasswordReset, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).mePasswordEmailPost(email, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get users quiz.
         * @summary Get users quiz.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meQuizGet(_with?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20030> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meQuizGet(_with, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get users relations.
         * @summary Get users relations.
         * @param {&#39;ADMIN&#39; | &#39;PARTNER&#39; | &#39;STUDENT&#39; | &#39;TEACHER&#39;} [type] Type of relations.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meRelationsGet(type?: 'ADMIN' | 'PARTNER' | 'STUDENT' | 'TEACHER', _with?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meRelationsGet(type, _with, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get users transactions.
         * @summary Get users transactions.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meTransactionsGet(_with?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20046> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meTransactionsGet(_with, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Login by user. Only admins can logging by user
         * @summary Login by user.
         * @param {number} user_id User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meUserTokensGet(user_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20045> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).meUserTokensGet(user_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all evaluation for user
         * @summary Get a listing of the UserEvaluation.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return MeApiFp(configuration).meEvaluationsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Store UsersEvaluation
         * @summary Store a newly created user evaluation in storage
         * @param {NewUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsPost(body?: NewUsersEvaluation, options?: any) {
            return MeApiFp(configuration).meEvaluationsPost(body, options)(fetch, basePath);
        },
        /**
         * Delete UsersEvaluation
         * @summary Delete the specified UsersEvaluation in storage
         * @param {number} teacher_id Teacher ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsTeacherIdDelete(teacher_id: number, options?: any) {
            return MeApiFp(configuration).meEvaluationsTeacherIdDelete(teacher_id, options)(fetch, basePath);
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersEvaluation
         * @param {number} teacher_id Teacher ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsTeacherIdGet(teacher_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return MeApiFp(configuration).meEvaluationsTeacherIdGet(teacher_id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update UsersEvaluation
         * @summary Update the specified UsersEvaluation in storage
         * @param {number} teacher_id Teacher ID
         * @param {UpdateUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meEvaluationsTeacherIdPut(teacher_id: number, body?: UpdateUsersEvaluation, options?: any) {
            return MeApiFp(configuration).meEvaluationsTeacherIdPut(teacher_id, body, options)(fetch, basePath);
        },
        /**
         * Get auth user.
         * @summary Get auth user.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(_with?: string, scenario?: string, options?: any) {
            return MeApiFp(configuration).meGet(_with, scenario, options)(fetch, basePath);
        },
        /**
         * Get user tokens by invite code.
         * @summary Get user tokens by invite code.
         * @param {string} code Invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInitTokensGet(code: string, options?: any) {
            return MeApiFp(configuration).meInitTokensGet(code, options)(fetch, basePath);
        },
        /**
         * Invite user. Only admins can invite user.
         * @summary Invite user by role.
         * @param {InviteUser} inviteUser Partner email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInvitePost(inviteUser: InviteUser, options?: any) {
            return MeApiFp(configuration).meInvitePost(inviteUser, options)(fetch, basePath);
        },
        /**
         * Invite user. Only admins can invite user.
         * @summary Invite user by role.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInvitesGet(_with?: string, scenario?: string, options?: any) {
            return MeApiFp(configuration).meInvitesGet(_with, scenario, options)(fetch, basePath);
        },
        /**
         * Get actual invoice for partner
         * @summary Generate actual invoice for partner
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meInvoiceStateGet(scenario?: string, options?: any) {
            return MeApiFp(configuration).meInvoiceStateGet(scenario, options)(fetch, basePath);
        },
        /**
         * Get user messages.
         * @summary Get user messages.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {number} [recipient_id] Recipient Id.
         * @param {number} [user_id] User Id.
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {boolean} [enabled] Enabled
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesGet(offset: number, limit: number, recipient_id?: number, user_id?: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', fields?: string, _with?: string, scenario?: string, options?: any) {
            return MeApiFp(configuration).meMessagesGet(offset, limit, recipient_id, user_id, search, sort_order, enabled, asc, fields, _with, scenario, options)(fetch, basePath);
        },
        /**
         * Get messages history.
         * @summary Get messages history.
         * @param {number} [recipient_id] History with concrete user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesHistoryGet(recipient_id?: number, options?: any) {
            return MeApiFp(configuration).meMessagesHistoryGet(recipient_id, options)(fetch, basePath);
        },
        /**
         * Create user messages.
         * @summary Create user messages.
         * @param {NewMessage} [body] Lesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesPost(body?: NewMessage, options?: any) {
            return MeApiFp(configuration).meMessagesPost(body, options)(fetch, basePath);
        },
        /**
         * Mark messages as read.
         * @summary Mark messages as read.
         * @param {ReadMessages} [body] Message ids array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessagesReadPut(body?: ReadMessages, options?: any) {
            return MeApiFp(configuration).meMessagesReadPut(body, options)(fetch, basePath);
        },
        /**
         * Change password.
         * @summary Change password
         * @param {PasswordReset} email Users email for password reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordChangePost(email: PasswordReset, options?: any) {
            return MeApiFp(configuration).mePasswordChangePost(email, options)(fetch, basePath);
        },
        /**
         * Send email to user for password reset.
         * @summary Send email to user for password reset.
         * @param {GetTokenForPasswordReset} email Users email for password reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mePasswordEmailPost(email: GetTokenForPasswordReset, options?: any) {
            return MeApiFp(configuration).mePasswordEmailPost(email, options)(fetch, basePath);
        },
        /**
         * Get users quiz.
         * @summary Get users quiz.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meQuizGet(_with?: string, scenario?: string, options?: any) {
            return MeApiFp(configuration).meQuizGet(_with, scenario, options)(fetch, basePath);
        },
        /**
         * Get users relations.
         * @summary Get users relations.
         * @param {&#39;ADMIN&#39; | &#39;PARTNER&#39; | &#39;STUDENT&#39; | &#39;TEACHER&#39;} [type] Type of relations.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meRelationsGet(type?: 'ADMIN' | 'PARTNER' | 'STUDENT' | 'TEACHER', _with?: string, scenario?: string, options?: any) {
            return MeApiFp(configuration).meRelationsGet(type, _with, scenario, options)(fetch, basePath);
        },
        /**
         * Get users transactions.
         * @summary Get users transactions.
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meTransactionsGet(_with?: string, options?: any) {
            return MeApiFp(configuration).meTransactionsGet(_with, options)(fetch, basePath);
        },
        /**
         * Login by user. Only admins can logging by user
         * @summary Login by user.
         * @param {number} user_id User ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meUserTokensGet(user_id: number, options?: any) {
            return MeApiFp(configuration).meUserTokensGet(user_id, options)(fetch, basePath);
        },
    };
};

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI {
    /**
     * Get all evaluation for user
     * @summary Get a listing of the UserEvaluation.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meEvaluationsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return MeApiFp(this.configuration).meEvaluationsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Store UsersEvaluation
     * @summary Store a newly created user evaluation in storage
     * @param {} [body] UsersEvaluation that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meEvaluationsPost(body?: NewUsersEvaluation, options?: any) {
        return MeApiFp(this.configuration).meEvaluationsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UsersEvaluation
     * @summary Delete the specified UsersEvaluation in storage
     * @param {} teacher_id Teacher ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meEvaluationsTeacherIdDelete(teacher_id: number, options?: any) {
        return MeApiFp(this.configuration).meEvaluationsTeacherIdDelete(teacher_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersEvaluation
     * @summary Display the specified UsersEvaluation
     * @param {} teacher_id Teacher ID
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meEvaluationsTeacherIdGet(teacher_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return MeApiFp(this.configuration).meEvaluationsTeacherIdGet(teacher_id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update UsersEvaluation
     * @summary Update the specified UsersEvaluation in storage
     * @param {} teacher_id Teacher ID
     * @param {} [body] UsersEvaluation that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meEvaluationsTeacherIdPut(teacher_id: number, body?: UpdateUsersEvaluation, options?: any) {
        return MeApiFp(this.configuration).meEvaluationsTeacherIdPut(teacher_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get auth user.
     * @summary Get auth user.
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meGet(_with?: string, scenario?: string, options?: any) {
        return MeApiFp(this.configuration).meGet(_with, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get user tokens by invite code.
     * @summary Get user tokens by invite code.
     * @param {} code Invite code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meInitTokensGet(code: string, options?: any) {
        return MeApiFp(this.configuration).meInitTokensGet(code, options)(this.fetch, this.basePath);
    }

    /**
     * Invite user. Only admins can invite user.
     * @summary Invite user by role.
     * @param {} inviteUser Partner email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meInvitePost(inviteUser: InviteUser, options?: any) {
        return MeApiFp(this.configuration).meInvitePost(inviteUser, options)(this.fetch, this.basePath);
    }

    /**
     * Invite user. Only admins can invite user.
     * @summary Invite user by role.
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meInvitesGet(_with?: string, scenario?: string, options?: any) {
        return MeApiFp(this.configuration).meInvitesGet(_with, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get actual invoice for partner
     * @summary Generate actual invoice for partner
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meInvoiceStateGet(scenario?: string, options?: any) {
        return MeApiFp(this.configuration).meInvoiceStateGet(scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get user messages.
     * @summary Get user messages.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [recipient_id] Recipient Id.
     * @param {} [user_id] User Id.
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [enabled] Enabled
     * @param {} [asc] asc
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meMessagesGet(offset: number, limit: number, recipient_id?: number, user_id?: number, search?: string, sort_order?: string, enabled?: boolean, asc?: 'asc' | 'desc', fields?: string, _with?: string, scenario?: string, options?: any) {
        return MeApiFp(this.configuration).meMessagesGet(offset, limit, recipient_id, user_id, search, sort_order, enabled, asc, fields, _with, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get messages history.
     * @summary Get messages history.
     * @param {} [recipient_id] History with concrete user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meMessagesHistoryGet(recipient_id?: number, options?: any) {
        return MeApiFp(this.configuration).meMessagesHistoryGet(recipient_id, options)(this.fetch, this.basePath);
    }

    /**
     * Create user messages.
     * @summary Create user messages.
     * @param {} [body] Lesson that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meMessagesPost(body?: NewMessage, options?: any) {
        return MeApiFp(this.configuration).meMessagesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Mark messages as read.
     * @summary Mark messages as read.
     * @param {} [body] Message ids array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meMessagesReadPut(body?: ReadMessages, options?: any) {
        return MeApiFp(this.configuration).meMessagesReadPut(body, options)(this.fetch, this.basePath);
    }

    /**
     * Change password.
     * @summary Change password
     * @param {} email Users email for password reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public mePasswordChangePost(email: PasswordReset, options?: any) {
        return MeApiFp(this.configuration).mePasswordChangePost(email, options)(this.fetch, this.basePath);
    }

    /**
     * Send email to user for password reset.
     * @summary Send email to user for password reset.
     * @param {} email Users email for password reset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public mePasswordEmailPost(email: GetTokenForPasswordReset, options?: any) {
        return MeApiFp(this.configuration).mePasswordEmailPost(email, options)(this.fetch, this.basePath);
    }

    /**
     * Get users quiz.
     * @summary Get users quiz.
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meQuizGet(_with?: string, scenario?: string, options?: any) {
        return MeApiFp(this.configuration).meQuizGet(_with, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get users relations.
     * @summary Get users relations.
     * @param {} [type] Type of relations.
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meRelationsGet(type?: 'ADMIN' | 'PARTNER' | 'STUDENT' | 'TEACHER', _with?: string, scenario?: string, options?: any) {
        return MeApiFp(this.configuration).meRelationsGet(type, _with, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get users transactions.
     * @summary Get users transactions.
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meTransactionsGet(_with?: string, options?: any) {
        return MeApiFp(this.configuration).meTransactionsGet(_with, options)(this.fetch, this.basePath);
    }

    /**
     * Login by user. Only admins can logging by user
     * @summary Login by user.
     * @param {} user_id User ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meUserTokensGet(user_id: number, options?: any) {
        return MeApiFp(this.configuration).meUserTokensGet(user_id, options)(this.fetch, this.basePath);
    }

}

/**
 * NotificationApi - fetch parameter creator
 * @export
 */
export const NotificationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all notification
         * @summary Get a listing of the notification.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {&#39;ALERT&#39; | &#39;REGULAR&#39; | &#39;INVITE_USER&#39;} [tag] Tag of notification.
         * @param {boolean} [unread] Get unread notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, tag?: 'ALERT' | 'REGULAR' | 'INVITE_USER', unread?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling notificationsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling notificationsGet.');
            }
            const localVarPath = `/notifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Notification
         * @summary Display the specified Notification
         * @param {string} id id of Notification
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsIdGet(id: string, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling notificationsIdGet.');
            }
            const localVarPath = `/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process notification.
         * @summary Process notification.
         * @param {string} id id of Notification. (uuid format)
         * @param {string} action Action for Notification.
         * @param {any} payload Payload for Notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsIdHandleActionPost(id: string, action: string, payload: any, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling notificationsIdHandleActionPost.');
            }
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling notificationsIdHandleActionPost.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling notificationsIdHandleActionPost.');
            }
            const localVarPath = `/notifications/{id}/handle/{action}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"action"}}`, encodeURIComponent(String(action)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark as read notification by id.
         * @summary Mark as read notification by id.
         * @param {string} id id of Notification. (uuid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsIdReadPost(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling notificationsIdReadPost.');
            }
            const localVarPath = `/notifications/{id}/read`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all notification
         * @summary Get a listing of the notification.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {&#39;ALERT&#39; | &#39;REGULAR&#39; | &#39;INVITE_USER&#39;} [tag] Tag of notification.
         * @param {boolean} [unread] Get unread notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, tag?: 'ALERT' | 'REGULAR' | 'INVITE_USER', unread?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20021> {
            const localVarFetchArgs = NotificationApiFetchParamCreator(configuration).notificationsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, tag, unread, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Notification
         * @summary Display the specified Notification
         * @param {string} id id of Notification
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsIdGet(id: string, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20022> {
            const localVarFetchArgs = NotificationApiFetchParamCreator(configuration).notificationsIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Process notification.
         * @summary Process notification.
         * @param {string} id id of Notification. (uuid format)
         * @param {string} action Action for Notification.
         * @param {any} payload Payload for Notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsIdHandleActionPost(id: string, action: string, payload: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20022> {
            const localVarFetchArgs = NotificationApiFetchParamCreator(configuration).notificationsIdHandleActionPost(id, action, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Mark as read notification by id.
         * @summary Mark as read notification by id.
         * @param {string} id id of Notification. (uuid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsIdReadPost(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20022> {
            const localVarFetchArgs = NotificationApiFetchParamCreator(configuration).notificationsIdReadPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all notification
         * @summary Get a listing of the notification.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {&#39;ALERT&#39; | &#39;REGULAR&#39; | &#39;INVITE_USER&#39;} [tag] Tag of notification.
         * @param {boolean} [unread] Get unread notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, tag?: 'ALERT' | 'REGULAR' | 'INVITE_USER', unread?: boolean, options?: any) {
            return NotificationApiFp(configuration).notificationsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, tag, unread, options)(fetch, basePath);
        },
        /**
         * Get Notification
         * @summary Display the specified Notification
         * @param {string} id id of Notification
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsIdGet(id: string, _with?: string, fields?: string, scenario?: string, options?: any) {
            return NotificationApiFp(configuration).notificationsIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Process notification.
         * @summary Process notification.
         * @param {string} id id of Notification. (uuid format)
         * @param {string} action Action for Notification.
         * @param {any} payload Payload for Notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsIdHandleActionPost(id: string, action: string, payload: any, options?: any) {
            return NotificationApiFp(configuration).notificationsIdHandleActionPost(id, action, payload, options)(fetch, basePath);
        },
        /**
         * Mark as read notification by id.
         * @summary Mark as read notification by id.
         * @param {string} id id of Notification. (uuid format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsIdReadPost(id: string, options?: any) {
            return NotificationApiFp(configuration).notificationsIdReadPost(id, options)(fetch, basePath);
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * Get all notification
     * @summary Get a listing of the notification.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {} [tag] Tag of notification.
     * @param {} [unread] Get unread notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notificationsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, tag?: 'ALERT' | 'REGULAR' | 'INVITE_USER', unread?: boolean, options?: any) {
        return NotificationApiFp(this.configuration).notificationsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, tag, unread, options)(this.fetch, this.basePath);
    }

    /**
     * Get Notification
     * @summary Display the specified Notification
     * @param {} id id of Notification
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notificationsIdGet(id: string, _with?: string, fields?: string, scenario?: string, options?: any) {
        return NotificationApiFp(this.configuration).notificationsIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Process notification.
     * @summary Process notification.
     * @param {} id id of Notification. (uuid format)
     * @param {} action Action for Notification.
     * @param {} payload Payload for Notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notificationsIdHandleActionPost(id: string, action: string, payload: any, options?: any) {
        return NotificationApiFp(this.configuration).notificationsIdHandleActionPost(id, action, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Mark as read notification by id.
     * @summary Mark as read notification by id.
     * @param {} id id of Notification. (uuid format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notificationsIdReadPost(id: string, options?: any) {
        return NotificationApiFp(this.configuration).notificationsIdReadPost(id, options)(this.fetch, this.basePath);
    }

}

/**
 * PackageApi - fetch parameter creator
 * @export
 */
export const PackageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all Packages
         * @summary Get a listing of the Packages.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling packagesGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling packagesGet.');
            }
            const localVarPath = `/packages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Package
         * @summary Remove the specified Package from storage
         * @param {number} id id of Package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling packagesIdDelete.');
            }
            const localVarPath = `/packages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Package
         * @summary Display the specified Package
         * @param {number} id id of Package
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdGet(id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling packagesIdGet.');
            }
            const localVarPath = `/packages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Package
         * @summary Update the specified Package in storage
         * @param {number} id id of Package
         * @param {UpdatePackage} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdPut(id: number, body?: UpdatePackage, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling packagesIdPut.');
            }
            const localVarPath = `/packages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePackage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reschedule Package lessons
         * @summary Reschedule all Package lessons   
         * @param {number} id id of Package
         * @param {NewRescheduleAllLessons} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdRescheduleLessonsPost(id: number, body?: NewRescheduleAllLessons, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling packagesIdRescheduleLessonsPost.');
            }
            const localVarPath = `/packages/{id}/reschedule-lessons`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewRescheduleAllLessons" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Package with lessons
         * @summary Create lessons for Package
         * @param {number} id id of Package
         * @param {NewLessonsForPackage} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdSchedulePost(id: number, body?: NewLessonsForPackage, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling packagesIdSchedulePost.');
            }
            const localVarPath = `/packages/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewLessonsForPackage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change Package State
         * @summary Change Package state
         * @param {number} id id of Package
         * @param {UpdatePackageState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdStatePut(id: number, body?: UpdatePackageState, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling packagesIdStatePut.');
            }
            const localVarPath = `/packages/{id}/state`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePackageState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns suggestion for this package teachers.
         * @summary Returns suggestion for this package teachers.
         * @param {number} id id of Package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdTeachersSuggestionsGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling packagesIdTeachersSuggestionsGet.');
            }
            const localVarPath = `/packages/{id}/teachers-suggestions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Package with lessons
         * @summary Create Package with lessons
         * @param {NewPackageWithLessons} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesPackageWithLessonsPost(body?: NewPackageWithLessons, options: any = {}): FetchArgs {
            const localVarPath = `/packages/package-with-lessons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewPackageWithLessons" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store Package
         * @summary Store a newly created Package in storage
         * @param {NewPackage} [body] Package that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesPost(body?: NewPackage, options: any = {}): FetchArgs {
            const localVarPath = `/packages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewPackage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackageApi - functional programming interface
 * @export
 */
export const PackageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all Packages
         * @summary Get a listing of the Packages.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20023> {
            const localVarFetchArgs = PackageApiFetchParamCreator(configuration).packagesGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete Package
         * @summary Remove the specified Package from storage
         * @param {number} id id of Package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = PackageApiFetchParamCreator(configuration).packagesIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Package
         * @summary Display the specified Package
         * @param {number} id id of Package
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = PackageApiFetchParamCreator(configuration).packagesIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Package
         * @summary Update the specified Package in storage
         * @param {number} id id of Package
         * @param {UpdatePackage} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdPut(id: number, body?: UpdatePackage, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = PackageApiFetchParamCreator(configuration).packagesIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reschedule Package lessons
         * @summary Reschedule all Package lessons   
         * @param {number} id id of Package
         * @param {NewRescheduleAllLessons} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdRescheduleLessonsPost(id: number, body?: NewRescheduleAllLessons, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = PackageApiFetchParamCreator(configuration).packagesIdRescheduleLessonsPost(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create Package with lessons
         * @summary Create lessons for Package
         * @param {number} id id of Package
         * @param {NewLessonsForPackage} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdSchedulePost(id: number, body?: NewLessonsForPackage, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = PackageApiFetchParamCreator(configuration).packagesIdSchedulePost(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change Package State
         * @summary Change Package state
         * @param {number} id id of Package
         * @param {UpdatePackageState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdStatePut(id: number, body?: UpdatePackageState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = PackageApiFetchParamCreator(configuration).packagesIdStatePut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns suggestion for this package teachers.
         * @summary Returns suggestion for this package teachers.
         * @param {number} id id of Package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdTeachersSuggestionsGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = PackageApiFetchParamCreator(configuration).packagesIdTeachersSuggestionsGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create Package with lessons
         * @summary Create Package with lessons
         * @param {NewPackageWithLessons} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesPackageWithLessonsPost(body?: NewPackageWithLessons, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = PackageApiFetchParamCreator(configuration).packagesPackageWithLessonsPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store Package
         * @summary Store a newly created Package in storage
         * @param {NewPackage} [body] Package that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesPost(body?: NewPackage, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = PackageApiFetchParamCreator(configuration).packagesPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PackageApi - factory interface
 * @export
 */
export const PackageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all Packages
         * @summary Get a listing of the Packages.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return PackageApiFp(configuration).packagesGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Delete Package
         * @summary Remove the specified Package from storage
         * @param {number} id id of Package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdDelete(id: number, options?: any) {
            return PackageApiFp(configuration).packagesIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get Package
         * @summary Display the specified Package
         * @param {number} id id of Package
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return PackageApiFp(configuration).packagesIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update Package
         * @summary Update the specified Package in storage
         * @param {number} id id of Package
         * @param {UpdatePackage} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdPut(id: number, body?: UpdatePackage, options?: any) {
            return PackageApiFp(configuration).packagesIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Reschedule Package lessons
         * @summary Reschedule all Package lessons   
         * @param {number} id id of Package
         * @param {NewRescheduleAllLessons} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdRescheduleLessonsPost(id: number, body?: NewRescheduleAllLessons, options?: any) {
            return PackageApiFp(configuration).packagesIdRescheduleLessonsPost(id, body, options)(fetch, basePath);
        },
        /**
         * Create Package with lessons
         * @summary Create lessons for Package
         * @param {number} id id of Package
         * @param {NewLessonsForPackage} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdSchedulePost(id: number, body?: NewLessonsForPackage, options?: any) {
            return PackageApiFp(configuration).packagesIdSchedulePost(id, body, options)(fetch, basePath);
        },
        /**
         * Change Package State
         * @summary Change Package state
         * @param {number} id id of Package
         * @param {UpdatePackageState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdStatePut(id: number, body?: UpdatePackageState, options?: any) {
            return PackageApiFp(configuration).packagesIdStatePut(id, body, options)(fetch, basePath);
        },
        /**
         * Returns suggestion for this package teachers.
         * @summary Returns suggestion for this package teachers.
         * @param {number} id id of Package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesIdTeachersSuggestionsGet(id: number, options?: any) {
            return PackageApiFp(configuration).packagesIdTeachersSuggestionsGet(id, options)(fetch, basePath);
        },
        /**
         * Create Package with lessons
         * @summary Create Package with lessons
         * @param {NewPackageWithLessons} [body] Package that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesPackageWithLessonsPost(body?: NewPackageWithLessons, options?: any) {
            return PackageApiFp(configuration).packagesPackageWithLessonsPost(body, options)(fetch, basePath);
        },
        /**
         * Store Package
         * @summary Store a newly created Package in storage
         * @param {NewPackage} [body] Package that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesPost(body?: NewPackage, options?: any) {
            return PackageApiFp(configuration).packagesPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * PackageApi - object-oriented interface
 * @export
 * @class PackageApi
 * @extends {BaseAPI}
 */
export class PackageApi extends BaseAPI {
    /**
     * Get all Packages
     * @summary Get a listing of the Packages.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public packagesGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return PackageApiFp(this.configuration).packagesGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Delete Package
     * @summary Remove the specified Package from storage
     * @param {} id id of Package
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public packagesIdDelete(id: number, options?: any) {
        return PackageApiFp(this.configuration).packagesIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get Package
     * @summary Display the specified Package
     * @param {} id id of Package
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public packagesIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return PackageApiFp(this.configuration).packagesIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update Package
     * @summary Update the specified Package in storage
     * @param {} id id of Package
     * @param {} [body] Package that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public packagesIdPut(id: number, body?: UpdatePackage, options?: any) {
        return PackageApiFp(this.configuration).packagesIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Reschedule Package lessons
     * @summary Reschedule all Package lessons   
     * @param {} id id of Package
     * @param {} [body] Package that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public packagesIdRescheduleLessonsPost(id: number, body?: NewRescheduleAllLessons, options?: any) {
        return PackageApiFp(this.configuration).packagesIdRescheduleLessonsPost(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create Package with lessons
     * @summary Create lessons for Package
     * @param {} id id of Package
     * @param {} [body] Package that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public packagesIdSchedulePost(id: number, body?: NewLessonsForPackage, options?: any) {
        return PackageApiFp(this.configuration).packagesIdSchedulePost(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Change Package State
     * @summary Change Package state
     * @param {} id id of Package
     * @param {} [body] Discount that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public packagesIdStatePut(id: number, body?: UpdatePackageState, options?: any) {
        return PackageApiFp(this.configuration).packagesIdStatePut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Returns suggestion for this package teachers.
     * @summary Returns suggestion for this package teachers.
     * @param {} id id of Package
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public packagesIdTeachersSuggestionsGet(id: number, options?: any) {
        return PackageApiFp(this.configuration).packagesIdTeachersSuggestionsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Create Package with lessons
     * @summary Create Package with lessons
     * @param {} [body] Package that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public packagesPackageWithLessonsPost(body?: NewPackageWithLessons, options?: any) {
        return PackageApiFp(this.configuration).packagesPackageWithLessonsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Store Package
     * @summary Store a newly created Package in storage
     * @param {} [body] Package that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public packagesPost(body?: NewPackage, options?: any) {
        return PackageApiFp(this.configuration).packagesPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * PaymentSystemApi - fetch parameter creator
 * @export
 */
export const PaymentSystemApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all PaymentSystems
         * @summary Get a listing of the PaymentSystems.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling paymentSystemsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling paymentSystemsGet.');
            }
            const localVarPath = `/payment-systems`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete PaymentSystem
         * @summary Remove the specified PaymentSystem from storage
         * @param {number} id id of PaymentSystem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling paymentSystemsIdDelete.');
            }
            const localVarPath = `/payment-systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get PaymentSystem
         * @summary Display the specified PaymentSystem
         * @param {number} id id of PaymentSystem
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling paymentSystemsIdGet.');
            }
            const localVarPath = `/payment-systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update PaymentSystem
         * @summary Update the specified PaymentSystem in storage
         * @param {number} id id of PaymentSystem
         * @param {PaymentSystem} [body] PaymentSystem that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdPut(id: number, body?: PaymentSystem, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling paymentSystemsIdPut.');
            }
            const localVarPath = `/payment-systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentSystem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change PaymentSystem State
         * @summary Change PaymentSystem state
         * @param {number} id id of PaymentSystem
         * @param {UpdatePaymentSystemState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdStatePut(id: number, body?: UpdatePaymentSystemState, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling paymentSystemsIdStatePut.');
            }
            const localVarPath = `/payment-systems/{id}/state`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePaymentSystemState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store PaymentSystem
         * @summary Store a newly created PaymentSystem in storage
         * @param {PaymentSystem} [body] PaymentSystem that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsPost(body?: PaymentSystem, options: any = {}): FetchArgs {
            const localVarPath = `/payment-systems`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentSystem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentSystemApi - functional programming interface
 * @export
 */
export const PaymentSystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all PaymentSystems
         * @summary Get a listing of the PaymentSystems.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20026> {
            const localVarFetchArgs = PaymentSystemApiFetchParamCreator(configuration).paymentSystemsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete PaymentSystem
         * @summary Remove the specified PaymentSystem from storage
         * @param {number} id id of PaymentSystem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = PaymentSystemApiFetchParamCreator(configuration).paymentSystemsIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get PaymentSystem
         * @summary Display the specified PaymentSystem
         * @param {number} id id of PaymentSystem
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20027> {
            const localVarFetchArgs = PaymentSystemApiFetchParamCreator(configuration).paymentSystemsIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update PaymentSystem
         * @summary Update the specified PaymentSystem in storage
         * @param {number} id id of PaymentSystem
         * @param {PaymentSystem} [body] PaymentSystem that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdPut(id: number, body?: PaymentSystem, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20027> {
            const localVarFetchArgs = PaymentSystemApiFetchParamCreator(configuration).paymentSystemsIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change PaymentSystem State
         * @summary Change PaymentSystem state
         * @param {number} id id of PaymentSystem
         * @param {UpdatePaymentSystemState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdStatePut(id: number, body?: UpdatePaymentSystemState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = PaymentSystemApiFetchParamCreator(configuration).paymentSystemsIdStatePut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store PaymentSystem
         * @summary Store a newly created PaymentSystem in storage
         * @param {PaymentSystem} [body] PaymentSystem that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsPost(body?: PaymentSystem, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20027> {
            const localVarFetchArgs = PaymentSystemApiFetchParamCreator(configuration).paymentSystemsPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PaymentSystemApi - factory interface
 * @export
 */
export const PaymentSystemApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all PaymentSystems
         * @summary Get a listing of the PaymentSystems.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return PaymentSystemApiFp(configuration).paymentSystemsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Delete PaymentSystem
         * @summary Remove the specified PaymentSystem from storage
         * @param {number} id id of PaymentSystem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdDelete(id: number, options?: any) {
            return PaymentSystemApiFp(configuration).paymentSystemsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get PaymentSystem
         * @summary Display the specified PaymentSystem
         * @param {number} id id of PaymentSystem
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return PaymentSystemApiFp(configuration).paymentSystemsIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update PaymentSystem
         * @summary Update the specified PaymentSystem in storage
         * @param {number} id id of PaymentSystem
         * @param {PaymentSystem} [body] PaymentSystem that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdPut(id: number, body?: PaymentSystem, options?: any) {
            return PaymentSystemApiFp(configuration).paymentSystemsIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Change PaymentSystem State
         * @summary Change PaymentSystem state
         * @param {number} id id of PaymentSystem
         * @param {UpdatePaymentSystemState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsIdStatePut(id: number, body?: UpdatePaymentSystemState, options?: any) {
            return PaymentSystemApiFp(configuration).paymentSystemsIdStatePut(id, body, options)(fetch, basePath);
        },
        /**
         * Store PaymentSystem
         * @summary Store a newly created PaymentSystem in storage
         * @param {PaymentSystem} [body] PaymentSystem that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsPost(body?: PaymentSystem, options?: any) {
            return PaymentSystemApiFp(configuration).paymentSystemsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * PaymentSystemApi - object-oriented interface
 * @export
 * @class PaymentSystemApi
 * @extends {BaseAPI}
 */
export class PaymentSystemApi extends BaseAPI {
    /**
     * Get all PaymentSystems
     * @summary Get a listing of the PaymentSystems.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemApi
     */
    public paymentSystemsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return PaymentSystemApiFp(this.configuration).paymentSystemsGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Delete PaymentSystem
     * @summary Remove the specified PaymentSystem from storage
     * @param {} id id of PaymentSystem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemApi
     */
    public paymentSystemsIdDelete(id: number, options?: any) {
        return PaymentSystemApiFp(this.configuration).paymentSystemsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get PaymentSystem
     * @summary Display the specified PaymentSystem
     * @param {} id id of PaymentSystem
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemApi
     */
    public paymentSystemsIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return PaymentSystemApiFp(this.configuration).paymentSystemsIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update PaymentSystem
     * @summary Update the specified PaymentSystem in storage
     * @param {} id id of PaymentSystem
     * @param {} [body] PaymentSystem that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemApi
     */
    public paymentSystemsIdPut(id: number, body?: PaymentSystem, options?: any) {
        return PaymentSystemApiFp(this.configuration).paymentSystemsIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Change PaymentSystem State
     * @summary Change PaymentSystem state
     * @param {} id id of PaymentSystem
     * @param {} [body] Discount that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemApi
     */
    public paymentSystemsIdStatePut(id: number, body?: UpdatePaymentSystemState, options?: any) {
        return PaymentSystemApiFp(this.configuration).paymentSystemsIdStatePut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store PaymentSystem
     * @summary Store a newly created PaymentSystem in storage
     * @param {} [body] PaymentSystem that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemApi
     */
    public paymentSystemsPost(body?: PaymentSystem, options?: any) {
        return PaymentSystemApiFp(this.configuration).paymentSystemsPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * PaypalApi - fetch parameter creator
 * @export
 */
export const PaypalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Pay for lessons through paypal.
         * @summary Pay for lessons through paypal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsPaypalPayPost(options: any = {}): FetchArgs {
            const localVarPath = `/payments/paypal/pay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirect to this url if payment has been completed successfully.
         * @summary Success pay for lessons through paypal.
         * @param {string} token Paypal token
         * @param {string} PayerID Paypal payer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsPaypalSuccessGet(token: string, PayerID: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling paymentsPaypalSuccessGet.');
            }
            // verify required parameter 'PayerID' is not null or undefined
            if (PayerID === null || PayerID === undefined) {
                throw new RequiredError('PayerID','Required parameter PayerID was null or undefined when calling paymentsPaypalSuccessGet.');
            }
            const localVarPath = `/payments/paypal/success`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (PayerID !== undefined) {
                localVarQueryParameter['PayerID'] = PayerID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaypalApi - functional programming interface
 * @export
 */
export const PaypalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Pay for lessons through paypal.
         * @summary Pay for lessons through paypal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsPaypalPayPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20028> {
            const localVarFetchArgs = PaypalApiFetchParamCreator(configuration).paymentsPaypalPayPost(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Redirect to this url if payment has been completed successfully.
         * @summary Success pay for lessons through paypal.
         * @param {string} token Paypal token
         * @param {string} PayerID Paypal payer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsPaypalSuccessGet(token: string, PayerID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = PaypalApiFetchParamCreator(configuration).paymentsPaypalSuccessGet(token, PayerID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PaypalApi - factory interface
 * @export
 */
export const PaypalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Pay for lessons through paypal.
         * @summary Pay for lessons through paypal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsPaypalPayPost(options?: any) {
            return PaypalApiFp(configuration).paymentsPaypalPayPost(options)(fetch, basePath);
        },
        /**
         * Redirect to this url if payment has been completed successfully.
         * @summary Success pay for lessons through paypal.
         * @param {string} token Paypal token
         * @param {string} PayerID Paypal payer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsPaypalSuccessGet(token: string, PayerID: string, options?: any) {
            return PaypalApiFp(configuration).paymentsPaypalSuccessGet(token, PayerID, options)(fetch, basePath);
        },
    };
};

/**
 * PaypalApi - object-oriented interface
 * @export
 * @class PaypalApi
 * @extends {BaseAPI}
 */
export class PaypalApi extends BaseAPI {
    /**
     * Pay for lessons through paypal.
     * @summary Pay for lessons through paypal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaypalApi
     */
    public paymentsPaypalPayPost(options?: any) {
        return PaypalApiFp(this.configuration).paymentsPaypalPayPost(options)(this.fetch, this.basePath);
    }

    /**
     * Redirect to this url if payment has been completed successfully.
     * @summary Success pay for lessons through paypal.
     * @param {} token Paypal token
     * @param {} PayerID Paypal payer id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaypalApi
     */
    public paymentsPaypalSuccessGet(token: string, PayerID: string, options?: any) {
        return PaypalApiFp(this.configuration).paymentsPaypalSuccessGet(token, PayerID, options)(this.fetch, this.basePath);
    }

}

/**
 * QuizApi - fetch parameter creator
 * @export
 */
export const QuizApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all Quiz
         * @summary Get a listing of the Quiz.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling quizGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling quizGet.');
            }
            const localVarPath = `/quiz`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Quiz
         * @summary Remove the specified Quiz from storage
         * @param {number} id id of Quiz
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling quizIdDelete.');
            }
            const localVarPath = `/quiz/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Quiz
         * @summary Display the specified Quiz
         * @param {number} id id of Quiz
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdGet(id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling quizIdGet.');
            }
            const localVarPath = `/quiz/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Quiz
         * @summary Update the specified Quiz in storage
         * @param {number} id id of Quiz
         * @param {NewQuiz} [body] Quiz that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdPut(id: number, body?: NewQuiz, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling quizIdPut.');
            }
            const localVarPath = `/quiz/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewQuiz" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change Quiz State
         * @summary Change Quiz state
         * @param {number} id id of Quiz
         * @param {UpdateQuizState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdStatePut(id: number, body?: UpdateQuizState, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling quizIdStatePut.');
            }
            const localVarPath = `/quiz/{id}/state`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateQuizState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store Quiz
         * @summary Store a newly created Quiz in storage
         * @param {NewQuiz} [body] Quiz that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizPost(body?: NewQuiz, options: any = {}): FetchArgs {
            const localVarPath = `/quiz`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewQuiz" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all QuizMarker
         * @summary Get a listing of the QuizMarker.
         * @param {number} quiz_id Quiz quiz
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizIdMarkersGet(quiz_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'quiz_id' is not null or undefined
            if (quiz_id === null || quiz_id === undefined) {
                throw new RequiredError('quiz_id','Required parameter quiz_id was null or undefined when calling quizQuizIdMarkersGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling quizQuizIdMarkersGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling quizQuizIdMarkersGet.');
            }
            const localVarPath = `/quiz/{quiz_id}/markers`
                .replace(`{${"quiz_id"}}`, encodeURIComponent(String(quiz_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete QuizMarker
         * @summary Remove the specified QuizMarker from storage
         * @param {number} quiz quiz of Quiz
         * @param {string} marker marker of QuizMarker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersMarkerDelete(quiz: number, marker: string, options: any = {}): FetchArgs {
            // verify required parameter 'quiz' is not null or undefined
            if (quiz === null || quiz === undefined) {
                throw new RequiredError('quiz','Required parameter quiz was null or undefined when calling quizQuizMarkersMarkerDelete.');
            }
            // verify required parameter 'marker' is not null or undefined
            if (marker === null || marker === undefined) {
                throw new RequiredError('marker','Required parameter marker was null or undefined when calling quizQuizMarkersMarkerDelete.');
            }
            const localVarPath = `/quiz/{quiz}/markers/{marker}`
                .replace(`{${"quiz"}}`, encodeURIComponent(String(quiz)))
                .replace(`{${"marker"}}`, encodeURIComponent(String(marker)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get QuizMarker
         * @summary Display the specified QuizMarker
         * @param {number} quiz quiz of Quiz
         * @param {string} marker marker of QuizMarker
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersMarkerGet(quiz: number, marker: string, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'quiz' is not null or undefined
            if (quiz === null || quiz === undefined) {
                throw new RequiredError('quiz','Required parameter quiz was null or undefined when calling quizQuizMarkersMarkerGet.');
            }
            // verify required parameter 'marker' is not null or undefined
            if (marker === null || marker === undefined) {
                throw new RequiredError('marker','Required parameter marker was null or undefined when calling quizQuizMarkersMarkerGet.');
            }
            const localVarPath = `/quiz/{quiz}/markers/{marker}`
                .replace(`{${"quiz"}}`, encodeURIComponent(String(quiz)))
                .replace(`{${"marker"}}`, encodeURIComponent(String(marker)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update QuizMarker
         * @summary Update the specified QuizMarker in storage
         * @param {number} quiz quiz of Quiz
         * @param {string} marker marker of QuizMarker
         * @param {NewQuizMarker} [body] QuizMarker that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersMarkerPut(quiz: number, marker: string, body?: NewQuizMarker, options: any = {}): FetchArgs {
            // verify required parameter 'quiz' is not null or undefined
            if (quiz === null || quiz === undefined) {
                throw new RequiredError('quiz','Required parameter quiz was null or undefined when calling quizQuizMarkersMarkerPut.');
            }
            // verify required parameter 'marker' is not null or undefined
            if (marker === null || marker === undefined) {
                throw new RequiredError('marker','Required parameter marker was null or undefined when calling quizQuizMarkersMarkerPut.');
            }
            const localVarPath = `/quiz/{quiz}/markers/{marker}`
                .replace(`{${"quiz"}}`, encodeURIComponent(String(quiz)))
                .replace(`{${"marker"}}`, encodeURIComponent(String(marker)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewQuizMarker" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store QuizMarker
         * @summary Store a newly created QuizMarker in storage
         * @param {number} quiz Quiz quiz
         * @param {NewQuizMarker} [body] QuizMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersPost(quiz: number, body?: NewQuizMarker, options: any = {}): FetchArgs {
            // verify required parameter 'quiz' is not null or undefined
            if (quiz === null || quiz === undefined) {
                throw new RequiredError('quiz','Required parameter quiz was null or undefined when calling quizQuizMarkersPost.');
            }
            const localVarPath = `/quiz/{quiz}/markers`
                .replace(`{${"quiz"}}`, encodeURIComponent(String(quiz)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewQuizMarker" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuizApi - functional programming interface
 * @export
 */
export const QuizApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all Quiz
         * @summary Get a listing of the Quiz.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20030> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete Quiz
         * @summary Remove the specified Quiz from storage
         * @param {number} id id of Quiz
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Quiz
         * @summary Display the specified Quiz
         * @param {number} id id of Quiz
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20031> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Quiz
         * @summary Update the specified Quiz in storage
         * @param {number} id id of Quiz
         * @param {NewQuiz} [body] Quiz that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdPut(id: number, body?: NewQuiz, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20031> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change Quiz State
         * @summary Change Quiz state
         * @param {number} id id of Quiz
         * @param {UpdateQuizState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdStatePut(id: number, body?: UpdateQuizState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizIdStatePut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store Quiz
         * @summary Store a newly created Quiz in storage
         * @param {NewQuiz} [body] Quiz that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizPost(body?: NewQuiz, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20031> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all QuizMarker
         * @summary Get a listing of the QuizMarker.
         * @param {number} quiz_id Quiz quiz
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizIdMarkersGet(quiz_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20032> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizQuizIdMarkersGet(quiz_id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete QuizMarker
         * @summary Remove the specified QuizMarker from storage
         * @param {number} quiz quiz of Quiz
         * @param {string} marker marker of QuizMarker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersMarkerDelete(quiz: number, marker: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizQuizMarkersMarkerDelete(quiz, marker, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get QuizMarker
         * @summary Display the specified QuizMarker
         * @param {number} quiz quiz of Quiz
         * @param {string} marker marker of QuizMarker
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersMarkerGet(quiz: number, marker: string, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20033> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizQuizMarkersMarkerGet(quiz, marker, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update QuizMarker
         * @summary Update the specified QuizMarker in storage
         * @param {number} quiz quiz of Quiz
         * @param {string} marker marker of QuizMarker
         * @param {NewQuizMarker} [body] QuizMarker that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersMarkerPut(quiz: number, marker: string, body?: NewQuizMarker, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20033> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizQuizMarkersMarkerPut(quiz, marker, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store QuizMarker
         * @summary Store a newly created QuizMarker in storage
         * @param {number} quiz Quiz quiz
         * @param {NewQuizMarker} [body] QuizMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersPost(quiz: number, body?: NewQuizMarker, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20033> {
            const localVarFetchArgs = QuizApiFetchParamCreator(configuration).quizQuizMarkersPost(quiz, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuizApi - factory interface
 * @export
 */
export const QuizApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all Quiz
         * @summary Get a listing of the Quiz.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return QuizApiFp(configuration).quizGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Delete Quiz
         * @summary Remove the specified Quiz from storage
         * @param {number} id id of Quiz
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdDelete(id: number, options?: any) {
            return QuizApiFp(configuration).quizIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get Quiz
         * @summary Display the specified Quiz
         * @param {number} id id of Quiz
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return QuizApiFp(configuration).quizIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update Quiz
         * @summary Update the specified Quiz in storage
         * @param {number} id id of Quiz
         * @param {NewQuiz} [body] Quiz that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdPut(id: number, body?: NewQuiz, options?: any) {
            return QuizApiFp(configuration).quizIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Change Quiz State
         * @summary Change Quiz state
         * @param {number} id id of Quiz
         * @param {UpdateQuizState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizIdStatePut(id: number, body?: UpdateQuizState, options?: any) {
            return QuizApiFp(configuration).quizIdStatePut(id, body, options)(fetch, basePath);
        },
        /**
         * Store Quiz
         * @summary Store a newly created Quiz in storage
         * @param {NewQuiz} [body] Quiz that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizPost(body?: NewQuiz, options?: any) {
            return QuizApiFp(configuration).quizPost(body, options)(fetch, basePath);
        },
        /**
         * Get all QuizMarker
         * @summary Get a listing of the QuizMarker.
         * @param {number} quiz_id Quiz quiz
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizIdMarkersGet(quiz_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return QuizApiFp(configuration).quizQuizIdMarkersGet(quiz_id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Delete QuizMarker
         * @summary Remove the specified QuizMarker from storage
         * @param {number} quiz quiz of Quiz
         * @param {string} marker marker of QuizMarker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersMarkerDelete(quiz: number, marker: string, options?: any) {
            return QuizApiFp(configuration).quizQuizMarkersMarkerDelete(quiz, marker, options)(fetch, basePath);
        },
        /**
         * Get QuizMarker
         * @summary Display the specified QuizMarker
         * @param {number} quiz quiz of Quiz
         * @param {string} marker marker of QuizMarker
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersMarkerGet(quiz: number, marker: string, _with?: string, fields?: string, scenario?: string, options?: any) {
            return QuizApiFp(configuration).quizQuizMarkersMarkerGet(quiz, marker, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update QuizMarker
         * @summary Update the specified QuizMarker in storage
         * @param {number} quiz quiz of Quiz
         * @param {string} marker marker of QuizMarker
         * @param {NewQuizMarker} [body] QuizMarker that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersMarkerPut(quiz: number, marker: string, body?: NewQuizMarker, options?: any) {
            return QuizApiFp(configuration).quizQuizMarkersMarkerPut(quiz, marker, body, options)(fetch, basePath);
        },
        /**
         * Store QuizMarker
         * @summary Store a newly created QuizMarker in storage
         * @param {number} quiz Quiz quiz
         * @param {NewQuizMarker} [body] QuizMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quizQuizMarkersPost(quiz: number, body?: NewQuizMarker, options?: any) {
            return QuizApiFp(configuration).quizQuizMarkersPost(quiz, body, options)(fetch, basePath);
        },
    };
};

/**
 * QuizApi - object-oriented interface
 * @export
 * @class QuizApi
 * @extends {BaseAPI}
 */
export class QuizApi extends BaseAPI {
    /**
     * Get all Quiz
     * @summary Get a listing of the Quiz.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return QuizApiFp(this.configuration).quizGet(offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Delete Quiz
     * @summary Remove the specified Quiz from storage
     * @param {} id id of Quiz
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizIdDelete(id: number, options?: any) {
        return QuizApiFp(this.configuration).quizIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get Quiz
     * @summary Display the specified Quiz
     * @param {} id id of Quiz
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return QuizApiFp(this.configuration).quizIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update Quiz
     * @summary Update the specified Quiz in storage
     * @param {} id id of Quiz
     * @param {} [body] Quiz that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizIdPut(id: number, body?: NewQuiz, options?: any) {
        return QuizApiFp(this.configuration).quizIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Change Quiz State
     * @summary Change Quiz state
     * @param {} id id of Quiz
     * @param {} [body] Discount that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizIdStatePut(id: number, body?: UpdateQuizState, options?: any) {
        return QuizApiFp(this.configuration).quizIdStatePut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store Quiz
     * @summary Store a newly created Quiz in storage
     * @param {} [body] Quiz that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizPost(body?: NewQuiz, options?: any) {
        return QuizApiFp(this.configuration).quizPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get all QuizMarker
     * @summary Get a listing of the QuizMarker.
     * @param {} quiz_id Quiz quiz
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizQuizIdMarkersGet(quiz_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return QuizApiFp(this.configuration).quizQuizIdMarkersGet(quiz_id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Delete QuizMarker
     * @summary Remove the specified QuizMarker from storage
     * @param {} quiz quiz of Quiz
     * @param {} marker marker of QuizMarker
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizQuizMarkersMarkerDelete(quiz: number, marker: string, options?: any) {
        return QuizApiFp(this.configuration).quizQuizMarkersMarkerDelete(quiz, marker, options)(this.fetch, this.basePath);
    }

    /**
     * Get QuizMarker
     * @summary Display the specified QuizMarker
     * @param {} quiz quiz of Quiz
     * @param {} marker marker of QuizMarker
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizQuizMarkersMarkerGet(quiz: number, marker: string, _with?: string, fields?: string, scenario?: string, options?: any) {
        return QuizApiFp(this.configuration).quizQuizMarkersMarkerGet(quiz, marker, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update QuizMarker
     * @summary Update the specified QuizMarker in storage
     * @param {} quiz quiz of Quiz
     * @param {} marker marker of QuizMarker
     * @param {} [body] QuizMarker that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizQuizMarkersMarkerPut(quiz: number, marker: string, body?: NewQuizMarker, options?: any) {
        return QuizApiFp(this.configuration).quizQuizMarkersMarkerPut(quiz, marker, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store QuizMarker
     * @summary Store a newly created QuizMarker in storage
     * @param {} quiz Quiz quiz
     * @param {} [body] QuizMarker that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    public quizQuizMarkersPost(quiz: number, body?: NewQuizMarker, options?: any) {
        return QuizApiFp(this.configuration).quizQuizMarkersPost(quiz, body, options)(this.fetch, this.basePath);
    }

}

/**
 * StatisticApi - fetch parameter creator
 * @export
 */
export const StatisticApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get counters month lessons statistic.
         * @summary Get counters month lessons statistic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsCountersMonthGet(options: any = {}): FetchArgs {
            const localVarPath = `/statistics/counters/month`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lesson statistic with filter by teacher and partner.
         * @summary Get lesson statistic with filter by teacher and partner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsEvaluationsGet(options: any = {}): FetchArgs {
            const localVarPath = `/statistics/evaluations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get owed teachers and partners.
         * @summary Get owed teachers and partners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsOwedGet(options: any = {}): FetchArgs {
            const localVarPath = `/statistics/owed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lesson statistic with filter by teacher and partner.
         * @summary Get lesson statistic with filter by teacher and partner.
         * @param {number} [partner_id] Partner Id
         * @param {number} [teacher_id] Teacher Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsPartnerTeacherGet(partner_id?: number, teacher_id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/statistics/partner-teacher`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (partner_id !== undefined) {
                localVarQueryParameter['partner_id'] = partner_id;
            }

            if (teacher_id !== undefined) {
                localVarQueryParameter['teacher_id'] = teacher_id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users statistic
         * @summary Get a listing of the UsersStatistic.
         * @param {number} partner_id Partner ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsStudentsGet(partner_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'partner_id' is not null or undefined
            if (partner_id === null || partner_id === undefined) {
                throw new RequiredError('partner_id','Required parameter partner_id was null or undefined when calling statisticsStudentsGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling statisticsStudentsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling statisticsStudentsGet.');
            }
            const localVarPath = `/statistics/students`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (partner_id !== undefined) {
                localVarQueryParameter['partner_id'] = partner_id;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get upcoming lessons statistic.
         * @summary Get upcoming lessons statistic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsUpcomingLessonsGet(options: any = {}): FetchArgs {
            const localVarPath = `/statistics/upcoming/lessons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticApi - functional programming interface
 * @export
 */
export const StatisticApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get counters month lessons statistic.
         * @summary Get counters month lessons statistic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsCountersMonthGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20035> {
            const localVarFetchArgs = StatisticApiFetchParamCreator(configuration).statisticsCountersMonthGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get lesson statistic with filter by teacher and partner.
         * @summary Get lesson statistic with filter by teacher and partner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsEvaluationsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20038> {
            const localVarFetchArgs = StatisticApiFetchParamCreator(configuration).statisticsEvaluationsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get owed teachers and partners.
         * @summary Get owed teachers and partners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsOwedGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20036> {
            const localVarFetchArgs = StatisticApiFetchParamCreator(configuration).statisticsOwedGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get lesson statistic with filter by teacher and partner.
         * @summary Get lesson statistic with filter by teacher and partner.
         * @param {number} [partner_id] Partner Id
         * @param {number} [teacher_id] Teacher Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsPartnerTeacherGet(partner_id?: number, teacher_id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20037> {
            const localVarFetchArgs = StatisticApiFetchParamCreator(configuration).statisticsPartnerTeacherGet(partner_id, teacher_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all users statistic
         * @summary Get a listing of the UsersStatistic.
         * @param {number} partner_id Partner ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsStudentsGet(partner_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20082> {
            const localVarFetchArgs = StatisticApiFetchParamCreator(configuration).statisticsStudentsGet(partner_id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get upcoming lessons statistic.
         * @summary Get upcoming lessons statistic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsUpcomingLessonsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20034> {
            const localVarFetchArgs = StatisticApiFetchParamCreator(configuration).statisticsUpcomingLessonsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatisticApi - factory interface
 * @export
 */
export const StatisticApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get counters month lessons statistic.
         * @summary Get counters month lessons statistic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsCountersMonthGet(options?: any) {
            return StatisticApiFp(configuration).statisticsCountersMonthGet(options)(fetch, basePath);
        },
        /**
         * Get lesson statistic with filter by teacher and partner.
         * @summary Get lesson statistic with filter by teacher and partner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsEvaluationsGet(options?: any) {
            return StatisticApiFp(configuration).statisticsEvaluationsGet(options)(fetch, basePath);
        },
        /**
         * Get owed teachers and partners.
         * @summary Get owed teachers and partners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsOwedGet(options?: any) {
            return StatisticApiFp(configuration).statisticsOwedGet(options)(fetch, basePath);
        },
        /**
         * Get lesson statistic with filter by teacher and partner.
         * @summary Get lesson statistic with filter by teacher and partner.
         * @param {number} [partner_id] Partner Id
         * @param {number} [teacher_id] Teacher Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsPartnerTeacherGet(partner_id?: number, teacher_id?: number, options?: any) {
            return StatisticApiFp(configuration).statisticsPartnerTeacherGet(partner_id, teacher_id, options)(fetch, basePath);
        },
        /**
         * Get all users statistic
         * @summary Get a listing of the UsersStatistic.
         * @param {number} partner_id Partner ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsStudentsGet(partner_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return StatisticApiFp(configuration).statisticsStudentsGet(partner_id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get upcoming lessons statistic.
         * @summary Get upcoming lessons statistic.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsUpcomingLessonsGet(options?: any) {
            return StatisticApiFp(configuration).statisticsUpcomingLessonsGet(options)(fetch, basePath);
        },
    };
};

/**
 * StatisticApi - object-oriented interface
 * @export
 * @class StatisticApi
 * @extends {BaseAPI}
 */
export class StatisticApi extends BaseAPI {
    /**
     * Get counters month lessons statistic.
     * @summary Get counters month lessons statistic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticApi
     */
    public statisticsCountersMonthGet(options?: any) {
        return StatisticApiFp(this.configuration).statisticsCountersMonthGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get lesson statistic with filter by teacher and partner.
     * @summary Get lesson statistic with filter by teacher and partner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticApi
     */
    public statisticsEvaluationsGet(options?: any) {
        return StatisticApiFp(this.configuration).statisticsEvaluationsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get owed teachers and partners.
     * @summary Get owed teachers and partners.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticApi
     */
    public statisticsOwedGet(options?: any) {
        return StatisticApiFp(this.configuration).statisticsOwedGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get lesson statistic with filter by teacher and partner.
     * @summary Get lesson statistic with filter by teacher and partner.
     * @param {} [partner_id] Partner Id
     * @param {} [teacher_id] Teacher Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticApi
     */
    public statisticsPartnerTeacherGet(partner_id?: number, teacher_id?: number, options?: any) {
        return StatisticApiFp(this.configuration).statisticsPartnerTeacherGet(partner_id, teacher_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get all users statistic
     * @summary Get a listing of the UsersStatistic.
     * @param {} partner_id Partner ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticApi
     */
    public statisticsStudentsGet(partner_id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return StatisticApiFp(this.configuration).statisticsStudentsGet(partner_id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get upcoming lessons statistic.
     * @summary Get upcoming lessons statistic.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticApi
     */
    public statisticsUpcomingLessonsGet(options?: any) {
        return StatisticApiFp(this.configuration).statisticsUpcomingLessonsGet(options)(this.fetch, this.basePath);
    }

}

/**
 * StripeApi - fetch parameter creator
 * @export
 */
export const StripeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This URL should be in stripe form as action for creating payments.
         * @summary This URL should be in stripe form as action for creating payments.
         * @param {number} amount Amount to charge in CENTS
         * @param {string} stripeToken stripeToken to charge
         * @param {string} [stripeEmail] email client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsStripePayPost(amount: number, stripeToken: string, stripeEmail?: string, options: any = {}): FetchArgs {
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling paymentsStripePayPost.');
            }
            // verify required parameter 'stripeToken' is not null or undefined
            if (stripeToken === null || stripeToken === undefined) {
                throw new RequiredError('stripeToken','Required parameter stripeToken was null or undefined when calling paymentsStripePayPost.');
            }
            const localVarPath = `/payments/stripe/pay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (stripeToken !== undefined) {
                localVarQueryParameter['stripeToken'] = stripeToken;
            }

            if (stripeEmail !== undefined) {
                localVarQueryParameter['stripeEmail'] = stripeEmail;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This URL should be in stripe form as action for creating payments.
         * @summary This URL should be in stripe form as action for creating payments.
         * @param {number} amount Amount to charge in CENTS
         * @param {string} stripeToken stripeToken to charge
         * @param {string} [stripeEmail] email client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsStripePayPost(amount: number, stripeToken: string, stripeEmail?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20039> {
            const localVarFetchArgs = StripeApiFetchParamCreator(configuration).paymentsStripePayPost(amount, stripeToken, stripeEmail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This URL should be in stripe form as action for creating payments.
         * @summary This URL should be in stripe form as action for creating payments.
         * @param {number} amount Amount to charge in CENTS
         * @param {string} stripeToken stripeToken to charge
         * @param {string} [stripeEmail] email client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentsStripePayPost(amount: number, stripeToken: string, stripeEmail?: string, options?: any) {
            return StripeApiFp(configuration).paymentsStripePayPost(amount, stripeToken, stripeEmail, options)(fetch, basePath);
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * This URL should be in stripe form as action for creating payments.
     * @summary This URL should be in stripe form as action for creating payments.
     * @param {} amount Amount to charge in CENTS
     * @param {} stripeToken stripeToken to charge
     * @param {} [stripeEmail] email client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public paymentsStripePayPost(amount: number, stripeToken: string, stripeEmail?: string, options?: any) {
        return StripeApiFp(this.configuration).paymentsStripePayPost(amount, stripeToken, stripeEmail, options)(this.fetch, this.basePath);
    }

}

/**
 * TimezonesApi - fetch parameter creator
 * @export
 */
export const TimezonesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all timezones
         * @summary Get a listing of the timezones.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timezonesGet(options: any = {}): FetchArgs {
            const localVarPath = `/timezones`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimezonesApi - functional programming interface
 * @export
 */
export const TimezonesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all timezones
         * @summary Get a listing of the timezones.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timezonesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20040> {
            const localVarFetchArgs = TimezonesApiFetchParamCreator(configuration).timezonesGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TimezonesApi - factory interface
 * @export
 */
export const TimezonesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all timezones
         * @summary Get a listing of the timezones.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timezonesGet(options?: any) {
            return TimezonesApiFp(configuration).timezonesGet(options)(fetch, basePath);
        },
    };
};

/**
 * TimezonesApi - object-oriented interface
 * @export
 * @class TimezonesApi
 * @extends {BaseAPI}
 */
export class TimezonesApi extends BaseAPI {
    /**
     * Get all timezones
     * @summary Get a listing of the timezones.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimezonesApi
     */
    public timezonesGet(options?: any) {
        return TimezonesApiFp(this.configuration).timezonesGet(options)(this.fetch, this.basePath);
    }

}

/**
 * TransactionApi - fetch parameter creator
 * @export
 */
export const TransactionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all Transaction
         * @summary Get a listing of the Transaction.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling transactionsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling transactionsGet.');
            }
            const localVarPath = `/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UserToUserFeedback
         * @summary Display the specified Transaction
         * @param {number} id id of Transaction
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsIdGet(id: number, _with?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling transactionsIdGet.');
            }
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all Transaction
         * @summary Get a listing of the Transaction.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20041> {
            const localVarFetchArgs = TransactionApiFetchParamCreator(configuration).transactionsGet(offset, limit, search, sort_order, asc, _with, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UserToUserFeedback
         * @summary Display the specified Transaction
         * @param {number} id id of Transaction
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsIdGet(id: number, _with?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20042> {
            const localVarFetchArgs = TransactionApiFetchParamCreator(configuration).transactionsIdGet(id, _with, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all Transaction
         * @summary Get a listing of the Transaction.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, options?: any) {
            return TransactionApiFp(configuration).transactionsGet(offset, limit, search, sort_order, asc, _with, options)(fetch, basePath);
        },
        /**
         * Get UserToUserFeedback
         * @summary Display the specified Transaction
         * @param {number} id id of Transaction
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsIdGet(id: number, _with?: string, options?: any) {
            return TransactionApiFp(configuration).transactionsIdGet(id, _with, options)(fetch, basePath);
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * Get all Transaction
     * @summary Get a listing of the Transaction.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionsGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, options?: any) {
        return TransactionApiFp(this.configuration).transactionsGet(offset, limit, search, sort_order, asc, _with, options)(this.fetch, this.basePath);
    }

    /**
     * Get UserToUserFeedback
     * @summary Display the specified Transaction
     * @param {} id id of Transaction
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionsIdGet(id: number, _with?: string, options?: any) {
        return TransactionApiFp(this.configuration).transactionsIdGet(id, _with, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all Users
         * @summary Get a listing of the Users.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {&#39;STUDENT&#39; | &#39;TEACHER&#39; | &#39;ADMIN&#39; | &#39;PARTNER&#39;} [role] role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, role?: 'STUDENT' | 'TEACHER' | 'ADMIN' | 'PARTNER', options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersGet.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersAvailability
         * @summary Display the specified UsersAvailability
         * @param {number} id User ID
         * @param {number} availabilityId UsersAvailability ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesAvailabilityIdGet(id: number, availabilityId: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdAvailabilitiesAvailabilityIdGet.');
            }
            // verify required parameter 'availabilityId' is not null or undefined
            if (availabilityId === null || availabilityId === undefined) {
                throw new RequiredError('availabilityId','Required parameter availabilityId was null or undefined when calling usersIdAvailabilitiesAvailabilityIdGet.');
            }
            const localVarPath = `/users/{id}/availabilities/{availabilityId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"availabilityId"}}`, encodeURIComponent(String(availabilityId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store UsersAvailability
         * @summary Store a newly created availability in storage
         * @param {number} id User ID
         * @param {Array&lt;NewUsersAvailability&gt;} [body] UsersAvailabilities that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesCollectionPost(id: number, body?: Array<NewUsersAvailability>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdAvailabilitiesCollectionPost.');
            }
            const localVarPath = `/users/{id}/availabilities/collection`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;NewUsersAvailability&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all availabilities for user
         * @summary Get a listing of the UsersAvailability.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdAvailabilitiesGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdAvailabilitiesGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdAvailabilitiesGet.');
            }
            const localVarPath = `/users/{id}/availabilities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store UsersAvailability
         * @summary Store a newly created availability in storage
         * @param {number} id User ID
         * @param {NewUsersAvailability} [body] UsersAvailability that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesPost(id: number, body?: NewUsersAvailability, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdAvailabilitiesPost.');
            }
            const localVarPath = `/users/{id}/availabilities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersAvailability" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersBalance
         * @summary Display the specified UsersBalance
         * @param {number} id User ID
         * @param {number} balanceId UsersBalance ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBalanceBalanceIdGet(id: number, balanceId: number, _with?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdBalanceBalanceIdGet.');
            }
            // verify required parameter 'balanceId' is not null or undefined
            if (balanceId === null || balanceId === undefined) {
                throw new RequiredError('balanceId','Required parameter balanceId was null or undefined when calling usersIdBalanceBalanceIdGet.');
            }
            const localVarPath = `/users/{id}/balance/{balanceId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"balanceId"}}`, encodeURIComponent(String(balanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all balance history for user
         * @summary Get a listing of the UsersBalance.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBalanceGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdBalanceGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdBalanceGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdBalanceGet.');
            }
            const localVarPath = `/users/{id}/balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new transaction which change users balance.
         * @summary Change users balance.
         * @param {number} id User ID
         * @param {NewUsersBalance} [body] UsersBalance that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBalancePost(id: number, body?: NewUsersBalance, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdBalancePost.');
            }
            const localVarPath = `/users/{id}/balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersBalance" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete User
         * @summary Remove the specified User from storage
         * @param {number} id id of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdDelete.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all documents for user
         * @summary Get a listing of the UsersDocuments.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDocumentsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdDocumentsGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdDocumentsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdDocumentsGet.');
            }
            const localVarPath = `/users/{id}/documents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all evaluation for user
         * @summary Get a listing of the UserEvaluation.
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdEvaluationsCurrentGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdEvaluationsCurrentGet.');
            }
            const localVarPath = `/users/{id}/evaluations/current`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all evaluation for user
         * @summary Get a listing of the UserEvaluation.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdEvaluationsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdEvaluationsGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdEvaluationsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdEvaluationsGet.');
            }
            const localVarPath = `/users/{id}/evaluations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all evaluation test for user
         * @summary Get a listing of the UserEvaluationTest.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdEvaluationsTestGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdEvaluationsTestGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdEvaluationsTestGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdEvaluationsTestGet.');
            }
            const localVarPath = `/users/{id}/evaluations-test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all availabilities for user
         * @summary Get a listing of the UsersAvailability.
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFreeAvailabilitiesGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdFreeAvailabilitiesGet.');
            }
            const localVarPath = `/users/{id}/free-availabilities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User
         * @summary Display the specified User
         * @param {number} id id of User
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdGet.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all lessons for user
         * @summary Get a listing of the UserLessons.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLessonsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdLessonsGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdLessonsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdLessonsGet.');
            }
            const localVarPath = `/users/{id}/lessons`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all markers for user
         * @summary Get a listing of the UsersMarker.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [type] Markers type
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMarkersGet(id: number, offset: number, limit: number, type?: string, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdMarkersGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdMarkersGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdMarkersGet.');
            }
            const localVarPath = `/users/{id}/markers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all media for user
         * @summary Get a listing of the UsersMedias.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMediaGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdMediaGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdMediaGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdMediaGet.');
            }
            const localVarPath = `/users/{id}/media`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User
         * @summary Get user packages
         * @param {number} id id of User
         * @param {&#39;asc&#39; | &#39;desc&#39;} [start] start sort
         * @param {&#39;asc&#39; | &#39;desc&#39;} [ends] ends sort
         * @param {&#39;active&#39; | &#39;finished&#39; | &#39;all&#39;} [state] state filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPackagesGet(id: number, start?: 'asc' | 'desc', ends?: 'asc' | 'desc', state?: 'active' | 'finished' | 'all', options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdPackagesGet.');
            }
            const localVarPath = `/users/{id}/packages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (ends !== undefined) {
                localVarQueryParameter['ends'] = ends;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update User
         * @summary Update the specified User in storage
         * @param {number} id id of User
         * @param {UpdateUser} [body] User that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(id: number, body?: UpdateUser, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdPut.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all quiz for user
         * @summary Get a listing of the UserQuiz.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdQuizGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdQuizGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdQuizGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdQuizGet.');
            }
            const localVarPath = `/users/{id}/quiz`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all rates for user
         * @summary Get a listing of the UsersRate.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRateGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdRateGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdRateGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdRateGet.');
            }
            const localVarPath = `/users/{id}/rate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store UsersRate
         * @summary Store a newly created rate in storage
         * @param {number} id User ID
         * @param {NewUsersRate} [body] UsersRate that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRatePost(id: number, body?: NewUsersRate, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdRatePost.');
            }
            const localVarPath = `/users/{id}/rate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersRate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all roles for user
         * @summary Get a listing of the UserRole.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRolesGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdRolesGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling usersIdRolesGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usersIdRolesGet.');
            }
            const localVarPath = `/users/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change User State
         * @summary Change User state
         * @param {number} id id of User
         * @param {UpdateUserState} [body] User state that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdStatePut(id: number, body?: UpdateUserState, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersIdStatePut.');
            }
            const localVarPath = `/users/{id}/state`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store User
         * @summary Store a newly created User in storage
         * @param {NewUser} [body] User that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(body?: NewUser, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change users status.
         * @summary Change users status.
         * @param {&#39;online&#39; | &#39;offline&#39;} status Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStatusStatusPost(status: 'online' | 'offline', options: any = {}): FetchArgs {
            // verify required parameter 'status' is not null or undefined
            if (status === null || status === undefined) {
                throw new RequiredError('status','Required parameter status was null or undefined when calling usersStatusStatusPost.');
            }
            const localVarPath = `/users/status/{status}`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsersAvailability
         * @summary Delete the specified UsersAvailability in storage
         * @param {number} user_id User ID
         * @param {number} availability_id UsersAvailability ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAvailabilitiesAvailabilityIdDelete(user_id: number, availability_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdAvailabilitiesAvailabilityIdDelete.');
            }
            // verify required parameter 'availability_id' is not null or undefined
            if (availability_id === null || availability_id === undefined) {
                throw new RequiredError('availability_id','Required parameter availability_id was null or undefined when calling usersUserIdAvailabilitiesAvailabilityIdDelete.');
            }
            const localVarPath = `/users/{user_id}/availabilities/{availability_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"availability_id"}}`, encodeURIComponent(String(availability_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store UsersDocument
         * @summary Store a newly created user document in storage
         * @param {number} user_id User ID
         * @param {NewUsersDocument} [body] UsersDocument that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsPost(user_id: number, body?: NewUsersDocument, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdDocumentsPost.');
            }
            const localVarPath = `/users/{user_id}/documents`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersDocument" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsersDocument
         * @summary Delete the specified UsersDocument in storage
         * @param {number} user_id User ID
         * @param {number} user_document_id User Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsUserDocumentIdDelete(user_id: number, user_document_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdDocumentsUserDocumentIdDelete.');
            }
            // verify required parameter 'user_document_id' is not null or undefined
            if (user_document_id === null || user_document_id === undefined) {
                throw new RequiredError('user_document_id','Required parameter user_document_id was null or undefined when calling usersUserIdDocumentsUserDocumentIdDelete.');
            }
            const localVarPath = `/users/{user_id}/documents/{user_document_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"user_document_id"}}`, encodeURIComponent(String(user_document_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersDocument
         * @summary Display the specified UsersDocument
         * @param {number} user_id User ID
         * @param {number} user_document_id User Document ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsUserDocumentIdGet(user_id: number, user_document_id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdDocumentsUserDocumentIdGet.');
            }
            // verify required parameter 'user_document_id' is not null or undefined
            if (user_document_id === null || user_document_id === undefined) {
                throw new RequiredError('user_document_id','Required parameter user_document_id was null or undefined when calling usersUserIdDocumentsUserDocumentIdGet.');
            }
            const localVarPath = `/users/{user_id}/documents/{user_document_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"user_document_id"}}`, encodeURIComponent(String(user_document_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UsersDocument
         * @summary Update the specified UsersDocument in storage
         * @param {number} user_id User ID
         * @param {number} user_document_id User Document ID
         * @param {UpdateUsersDocument} [body] UsersDocument that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsUserDocumentIdPost(user_id: number, user_document_id: number, body?: UpdateUsersDocument, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdDocumentsUserDocumentIdPost.');
            }
            // verify required parameter 'user_document_id' is not null or undefined
            if (user_document_id === null || user_document_id === undefined) {
                throw new RequiredError('user_document_id','Required parameter user_document_id was null or undefined when calling usersUserIdDocumentsUserDocumentIdPost.');
            }
            const localVarPath = `/users/{user_id}/documents/{user_document_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"user_document_id"}}`, encodeURIComponent(String(user_document_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUsersDocument" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store UsersEvaluation
         * @summary Store a newly created user evaluation in storage
         * @param {number} user_id User ID
         * @param {NewUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsPost(user_id: number, body?: NewUsersEvaluation, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdEvaluationsPost.');
            }
            const localVarPath = `/users/{user_id}/evaluations`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersEvaluation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsersEvaluation
         * @summary Delete the specified UsersEvaluation in storage
         * @param {number} user_id User ID
         * @param {number} teacher_id Teacher ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTeacherIdDelete(user_id: number, teacher_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdEvaluationsTeacherIdDelete.');
            }
            // verify required parameter 'teacher_id' is not null or undefined
            if (teacher_id === null || teacher_id === undefined) {
                throw new RequiredError('teacher_id','Required parameter teacher_id was null or undefined when calling usersUserIdEvaluationsTeacherIdDelete.');
            }
            const localVarPath = `/users/{user_id}/evaluations/{teacher_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"teacher_id"}}`, encodeURIComponent(String(teacher_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersEvaluation
         * @param {number} user_id User ID
         * @param {number} teacher_id Teacher ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTeacherIdGet(user_id: number, teacher_id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdEvaluationsTeacherIdGet.');
            }
            // verify required parameter 'teacher_id' is not null or undefined
            if (teacher_id === null || teacher_id === undefined) {
                throw new RequiredError('teacher_id','Required parameter teacher_id was null or undefined when calling usersUserIdEvaluationsTeacherIdGet.');
            }
            const localVarPath = `/users/{user_id}/evaluations/{teacher_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"teacher_id"}}`, encodeURIComponent(String(teacher_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UsersEvaluation
         * @summary Update the specified UsersEvaluation in storage
         * @param {number} user_id User ID
         * @param {number} teacher_id Teacher ID
         * @param {UpdateUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTeacherIdPut(user_id: number, teacher_id: number, body?: UpdateUsersEvaluation, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdEvaluationsTeacherIdPut.');
            }
            // verify required parameter 'teacher_id' is not null or undefined
            if (teacher_id === null || teacher_id === undefined) {
                throw new RequiredError('teacher_id','Required parameter teacher_id was null or undefined when calling usersUserIdEvaluationsTeacherIdPut.');
            }
            const localVarPath = `/users/{user_id}/evaluations/{teacher_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"teacher_id"}}`, encodeURIComponent(String(teacher_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUsersEvaluation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsersEvaluationTest
         * @summary Delete the specified UsersEvaluationTest in storage
         * @param {number} user_id User ID
         * @param {number} evaluations_question_id Evaluations Question ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestEvaluationsQuestionIdDelete(user_id: number, evaluations_question_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdEvaluationsTestEvaluationsQuestionIdDelete.');
            }
            // verify required parameter 'evaluations_question_id' is not null or undefined
            if (evaluations_question_id === null || evaluations_question_id === undefined) {
                throw new RequiredError('evaluations_question_id','Required parameter evaluations_question_id was null or undefined when calling usersUserIdEvaluationsTestEvaluationsQuestionIdDelete.');
            }
            const localVarPath = `/users/{user_id}/evaluations-test/{evaluations_question_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"evaluations_question_id"}}`, encodeURIComponent(String(evaluations_question_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersEvaluation
         * @param {number} user_id User ID
         * @param {number} evaluations_question_id Evaluations question ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestEvaluationsQuestionIdGet(user_id: number, evaluations_question_id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdEvaluationsTestEvaluationsQuestionIdGet.');
            }
            // verify required parameter 'evaluations_question_id' is not null or undefined
            if (evaluations_question_id === null || evaluations_question_id === undefined) {
                throw new RequiredError('evaluations_question_id','Required parameter evaluations_question_id was null or undefined when calling usersUserIdEvaluationsTestEvaluationsQuestionIdGet.');
            }
            const localVarPath = `/users/{user_id}/evaluations-test/{evaluations_question_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"evaluations_question_id"}}`, encodeURIComponent(String(evaluations_question_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UsersEvaluationTest
         * @summary Update the specified UsersEvaluationTest in storage
         * @param {number} user_id User ID
         * @param {number} evaluations_question_id Evaluations question ID
         * @param {UpdateUsersEvaluationTest} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestEvaluationsQuestionIdPut(user_id: number, evaluations_question_id: number, body?: UpdateUsersEvaluationTest, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdEvaluationsTestEvaluationsQuestionIdPut.');
            }
            // verify required parameter 'evaluations_question_id' is not null or undefined
            if (evaluations_question_id === null || evaluations_question_id === undefined) {
                throw new RequiredError('evaluations_question_id','Required parameter evaluations_question_id was null or undefined when calling usersUserIdEvaluationsTestEvaluationsQuestionIdPut.');
            }
            const localVarPath = `/users/{user_id}/evaluations-test/{evaluations_question_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"evaluations_question_id"}}`, encodeURIComponent(String(evaluations_question_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUsersEvaluationTest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store UsersEvaluationTest
         * @summary Store a newly created user evaluation test in storage
         * @param {number} user_id User ID
         * @param {NewUsersEvaluationTest} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestPost(user_id: number, body?: NewUsersEvaluationTest, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdEvaluationsTestPost.');
            }
            const localVarPath = `/users/{user_id}/evaluations-test`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersEvaluationTest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change UsersLesson State
         * @summary Change UsersLesson state
         * @param {number} user_id User ID
         * @param {string} secret User email in md5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsIcsGet(user_id: number, secret: string, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdLessonsIcsGet.');
            }
            // verify required parameter 'secret' is not null or undefined
            if (secret === null || secret === undefined) {
                throw new RequiredError('secret','Required parameter secret was null or undefined when calling usersUserIdLessonsIcsGet.');
            }
            const localVarPath = `/users/{user_id}/lessons/ics`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsersLesson
         * @summary Delete the specified UsersLesson in storage
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdDelete(user_id: number, lesson_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdLessonsLessonIdDelete.');
            }
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling usersUserIdLessonsLessonIdDelete.');
            }
            const localVarPath = `/users/{user_id}/lessons/{lesson_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersLesson
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdGet(user_id: number, lesson_id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdLessonsLessonIdGet.');
            }
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling usersUserIdLessonsLessonIdGet.');
            }
            const localVarPath = `/users/{user_id}/lessons/{lesson_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UsersLesson
         * @summary Update the specified UsersLesson in storage
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {UpdateUsersLesson} [body] UsersLesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdPut(user_id: number, lesson_id: number, body?: UpdateUsersLesson, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdLessonsLessonIdPut.');
            }
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling usersUserIdLessonsLessonIdPut.');
            }
            const localVarPath = `/users/{user_id}/lessons/{lesson_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUsersLesson" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change UsersLesson State
         * @summary Change UsersLesson state
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {UpdateUserLessonState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdStatePut(user_id: number, lesson_id: number, body?: UpdateUserLessonState, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdLessonsLessonIdStatePut.');
            }
            // verify required parameter 'lesson_id' is not null or undefined
            if (lesson_id === null || lesson_id === undefined) {
                throw new RequiredError('lesson_id','Required parameter lesson_id was null or undefined when calling usersUserIdLessonsLessonIdStatePut.');
            }
            const localVarPath = `/users/{user_id}/lessons/{lesson_id}/state`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"lesson_id"}}`, encodeURIComponent(String(lesson_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserLessonState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store Users
         * @summary Store a newly created user lessons in storage
         * @param {number} user_id User ID
         * @param {NewUsersLesson} [body] NewUsersLesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsPost(user_id: number, body?: NewUsersLesson, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdLessonsPost.');
            }
            const localVarPath = `/users/{user_id}/lessons`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersLesson" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsersMarker
         * @summary Delete the specified UsersMarker in storage
         * @param {number} user_id User ID
         * @param {string} code Marker code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersCodeDelete(user_id: number, code: string, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdMarkersCodeDelete.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling usersUserIdMarkersCodeDelete.');
            }
            const localVarPath = `/users/{user_id}/markers/{code}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersMarker
         * @param {number} user_id User ID
         * @param {string} code Marker Code
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersCodeGet(user_id: number, code: string, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdMarkersCodeGet.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling usersUserIdMarkersCodeGet.');
            }
            const localVarPath = `/users/{user_id}/markers/{code}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UsersMarker
         * @summary Update the specified UsersMarker in storage
         * @param {number} user_id User ID
         * @param {string} code Marker Code
         * @param {UpdateUsersMarker} [body] UsersMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersCodePut(user_id: number, code: string, body?: UpdateUsersMarker, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdMarkersCodePut.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling usersUserIdMarkersCodePut.');
            }
            const localVarPath = `/users/{user_id}/markers/{code}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUsersMarker" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store Users
         * @summary Store a newly created user markers in storage
         * @param {number} user_id User ID
         * @param {NewUsersMarker} [body] NewUsersMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersPost(user_id: number, body?: NewUsersMarker, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdMarkersPost.');
            }
            const localVarPath = `/users/{user_id}/markers`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersMarker" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsersMedia
         * @summary Delete the specified UsersMedia in storage
         * @param {number} user_id User ID
         * @param {number} media_id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaMediaIdDelete(user_id: number, media_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdMediaMediaIdDelete.');
            }
            // verify required parameter 'media_id' is not null or undefined
            if (media_id === null || media_id === undefined) {
                throw new RequiredError('media_id','Required parameter media_id was null or undefined when calling usersUserIdMediaMediaIdDelete.');
            }
            const localVarPath = `/users/{user_id}/media/{media_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"media_id"}}`, encodeURIComponent(String(media_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersMedia
         * @summary Display the specified UsersMedia
         * @param {number} user_id User ID
         * @param {number} media_id Media ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaMediaIdGet(user_id: number, media_id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdMediaMediaIdGet.');
            }
            // verify required parameter 'media_id' is not null or undefined
            if (media_id === null || media_id === undefined) {
                throw new RequiredError('media_id','Required parameter media_id was null or undefined when calling usersUserIdMediaMediaIdGet.');
            }
            const localVarPath = `/users/{user_id}/media/{media_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"media_id"}}`, encodeURIComponent(String(media_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UsersMedia
         * @summary Update the specified UsersMedia in storage
         * @param {number} user_id User ID
         * @param {number} media_id Media ID
         * @param {UpdateUsersMedia} [body] UsersMedia that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaMediaIdPost(user_id: number, media_id: number, body?: UpdateUsersMedia, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdMediaMediaIdPost.');
            }
            // verify required parameter 'media_id' is not null or undefined
            if (media_id === null || media_id === undefined) {
                throw new RequiredError('media_id','Required parameter media_id was null or undefined when calling usersUserIdMediaMediaIdPost.');
            }
            const localVarPath = `/users/{user_id}/media/{media_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"media_id"}}`, encodeURIComponent(String(media_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUsersMedia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store UsersMedia
         * @summary Store a newly created user document in storage
         * @param {number} user_id User ID
         * @param {NewUsersMedia} [body] UsersMedia that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaPost(user_id: number, body?: NewUsersMedia, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdMediaPost.');
            }
            const localVarPath = `/users/{user_id}/media`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersMedia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store Users
         * @summary Store a newly created user quiz in storage
         * @param {number} user_id User ID
         * @param {NewUsersQuiz} [body] NewUsersQuiz that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizPost(user_id: number, body?: NewUsersQuiz, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdQuizPost.');
            }
            const localVarPath = `/users/{user_id}/quiz`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersQuiz" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsersQuiz
         * @summary Delete the specified UsersQuiz in storage
         * @param {number} user_id User ID
         * @param {number} quiz_id Lesson ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizQuizIdDelete(user_id: number, quiz_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdQuizQuizIdDelete.');
            }
            // verify required parameter 'quiz_id' is not null or undefined
            if (quiz_id === null || quiz_id === undefined) {
                throw new RequiredError('quiz_id','Required parameter quiz_id was null or undefined when calling usersUserIdQuizQuizIdDelete.');
            }
            const localVarPath = `/users/{user_id}/quiz/{quiz_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"quiz_id"}}`, encodeURIComponent(String(quiz_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersQuiz
         * @param {number} user_id User ID
         * @param {number} quiz_id Lesson ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizQuizIdGet(user_id: number, quiz_id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdQuizQuizIdGet.');
            }
            // verify required parameter 'quiz_id' is not null or undefined
            if (quiz_id === null || quiz_id === undefined) {
                throw new RequiredError('quiz_id','Required parameter quiz_id was null or undefined when calling usersUserIdQuizQuizIdGet.');
            }
            const localVarPath = `/users/{user_id}/quiz/{quiz_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"quiz_id"}}`, encodeURIComponent(String(quiz_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UsersQuiz
         * @summary Update the specified UsersQuiz in storage
         * @param {number} user_id User ID
         * @param {number} quiz_id Lesson ID
         * @param {UpdateUsersQuiz} [body] UsersQuiz that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizQuizIdPut(user_id: number, quiz_id: number, body?: UpdateUsersQuiz, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdQuizQuizIdPut.');
            }
            // verify required parameter 'quiz_id' is not null or undefined
            if (quiz_id === null || quiz_id === undefined) {
                throw new RequiredError('quiz_id','Required parameter quiz_id was null or undefined when calling usersUserIdQuizQuizIdPut.');
            }
            const localVarPath = `/users/{user_id}/quiz/{quiz_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"quiz_id"}}`, encodeURIComponent(String(quiz_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUsersQuiz" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store Users
         * @summary Store a newly created user roles in storage
         * @param {number} user_id User ID
         * @param {NewUsersRole} [body] NewUsersRole that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesPost(user_id: number, body?: NewUsersRole, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdRolesPost.');
            }
            const localVarPath = `/users/{user_id}/roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUsersRole" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsersRole
         * @summary Delete the specified UsersRole in storage
         * @param {number} user_id User ID
         * @param {number} role Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesRoleDelete(user_id: number, role: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdRolesRoleDelete.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling usersUserIdRolesRoleDelete.');
            }
            const localVarPath = `/users/{user_id}/roles/{role}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersRole
         * @param {number} user_id User ID
         * @param {number} role Role
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesRoleGet(user_id: number, role: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdRolesRoleGet.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling usersUserIdRolesRoleGet.');
            }
            const localVarPath = `/users/{user_id}/roles/{role}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UsersRole
         * @summary Update the specified UsersRole in storage
         * @param {number} user_id User ID
         * @param {string} role Role
         * @param {UpdateUsersRole} [body] UsersRole that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesRolePut(user_id: number, role: string, body?: UpdateUsersRole, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling usersUserIdRolesRolePut.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling usersUserIdRolesRolePut.');
            }
            const localVarPath = `/users/{user_id}/roles/{role}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUsersRole" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all Users
         * @summary Get a listing of the Users.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {&#39;STUDENT&#39; | &#39;TEACHER&#39; | &#39;ADMIN&#39; | &#39;PARTNER&#39;} [role] role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, role?: 'STUDENT' | 'TEACHER' | 'ADMIN' | 'PARTNER', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersGet(offset, limit, search, sort_order, asc, _with, fields, scenario, role, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersAvailability
         * @summary Display the specified UsersAvailability
         * @param {number} id User ID
         * @param {number} availabilityId UsersAvailability ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesAvailabilityIdGet(id: number, availabilityId: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20054> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdAvailabilitiesAvailabilityIdGet(id, availabilityId, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store UsersAvailability
         * @summary Store a newly created availability in storage
         * @param {number} id User ID
         * @param {Array&lt;NewUsersAvailability&gt;} [body] UsersAvailabilities that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesCollectionPost(id: number, body?: Array<NewUsersAvailability>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20053> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdAvailabilitiesCollectionPost(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all availabilities for user
         * @summary Get a listing of the UsersAvailability.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20053> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdAvailabilitiesGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store UsersAvailability
         * @summary Store a newly created availability in storage
         * @param {number} id User ID
         * @param {NewUsersAvailability} [body] UsersAvailability that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesPost(id: number, body?: NewUsersAvailability, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20054> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdAvailabilitiesPost(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersBalance
         * @summary Display the specified UsersBalance
         * @param {number} id User ID
         * @param {number} balanceId UsersBalance ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBalanceBalanceIdGet(id: number, balanceId: number, _with?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20056> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdBalanceBalanceIdGet(id, balanceId, _with, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all balance history for user
         * @summary Get a listing of the UsersBalance.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBalanceGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20055> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdBalanceGet(id, offset, limit, search, sort_order, asc, _with, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create new transaction which change users balance.
         * @summary Change users balance.
         * @param {number} id User ID
         * @param {NewUsersBalance} [body] UsersBalance that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBalancePost(id: number, body?: NewUsersBalance, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20056> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdBalancePost(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete User
         * @summary Remove the specified User from storage
         * @param {number} id id of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all documents for user
         * @summary Get a listing of the UsersDocuments.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDocumentsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20057> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdDocumentsGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all evaluation for user
         * @summary Get a listing of the UserEvaluation.
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdEvaluationsCurrentGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20048> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdEvaluationsCurrentGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all evaluation for user
         * @summary Get a listing of the UserEvaluation.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdEvaluationsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20048> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdEvaluationsGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all evaluation test for user
         * @summary Get a listing of the UserEvaluationTest.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdEvaluationsTestGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20060> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdEvaluationsTestGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all availabilities for user
         * @summary Get a listing of the UsersAvailability.
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFreeAvailabilitiesGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20053> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdFreeAvailabilitiesGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get User
         * @summary Display the specified User
         * @param {number} id id of User
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20043> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all lessons for user
         * @summary Get a listing of the UserLessons.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLessonsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20064> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdLessonsGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all markers for user
         * @summary Get a listing of the UsersMarker.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [type] Markers type
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMarkersGet(id: number, offset: number, limit: number, type?: string, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20067> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdMarkersGet(id, offset, limit, type, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all media for user
         * @summary Get a listing of the UsersMedias.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMediaGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20070> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdMediaGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get User
         * @summary Get user packages
         * @param {number} id id of User
         * @param {&#39;asc&#39; | &#39;desc&#39;} [start] start sort
         * @param {&#39;asc&#39; | &#39;desc&#39;} [ends] ends sort
         * @param {&#39;active&#39; | &#39;finished&#39; | &#39;all&#39;} [state] state filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPackagesGet(id: number, start?: 'asc' | 'desc', ends?: 'asc' | 'desc', state?: 'active' | 'finished' | 'all', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20044> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdPackagesGet(id, start, ends, state, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update User
         * @summary Update the specified User in storage
         * @param {number} id id of User
         * @param {UpdateUser} [body] User that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(id: number, body?: UpdateUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20043> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all quiz for user
         * @summary Get a listing of the UserQuiz.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdQuizGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20074> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdQuizGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all rates for user
         * @summary Get a listing of the UsersRate.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRateGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20077> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdRateGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store UsersRate
         * @summary Store a newly created rate in storage
         * @param {number} id User ID
         * @param {NewUsersRate} [body] UsersRate that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRatePost(id: number, body?: NewUsersRate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20078> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdRatePost(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all roles for user
         * @summary Get a listing of the UserRole.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRolesGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20079> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdRolesGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change User State
         * @summary Change User state
         * @param {number} id id of User
         * @param {UpdateUserState} [body] User state that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdStatePut(id: number, body?: UpdateUserState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdStatePut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store User
         * @summary Store a newly created User in storage
         * @param {NewUser} [body] User that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(body?: NewUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20043> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change users status.
         * @summary Change users status.
         * @param {&#39;online&#39; | &#39;offline&#39;} status Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStatusStatusPost(status: 'online' | 'offline', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20043> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersStatusStatusPost(status, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UsersAvailability
         * @summary Delete the specified UsersAvailability in storage
         * @param {number} user_id User ID
         * @param {number} availability_id UsersAvailability ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAvailabilitiesAvailabilityIdDelete(user_id: number, availability_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdAvailabilitiesAvailabilityIdDelete(user_id, availability_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store UsersDocument
         * @summary Store a newly created user document in storage
         * @param {number} user_id User ID
         * @param {NewUsersDocument} [body] UsersDocument that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsPost(user_id: number, body?: NewUsersDocument, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20058> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdDocumentsPost(user_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UsersDocument
         * @summary Delete the specified UsersDocument in storage
         * @param {number} user_id User ID
         * @param {number} user_document_id User Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsUserDocumentIdDelete(user_id: number, user_document_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdDocumentsUserDocumentIdDelete(user_id, user_document_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersDocument
         * @summary Display the specified UsersDocument
         * @param {number} user_id User ID
         * @param {number} user_document_id User Document ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsUserDocumentIdGet(user_id: number, user_document_id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20058> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdDocumentsUserDocumentIdGet(user_id, user_document_id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update UsersDocument
         * @summary Update the specified UsersDocument in storage
         * @param {number} user_id User ID
         * @param {number} user_document_id User Document ID
         * @param {UpdateUsersDocument} [body] UsersDocument that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsUserDocumentIdPost(user_id: number, user_document_id: number, body?: UpdateUsersDocument, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20059> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdDocumentsUserDocumentIdPost(user_id, user_document_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store UsersEvaluation
         * @summary Store a newly created user evaluation in storage
         * @param {number} user_id User ID
         * @param {NewUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsPost(user_id: number, body?: NewUsersEvaluation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20049> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdEvaluationsPost(user_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UsersEvaluation
         * @summary Delete the specified UsersEvaluation in storage
         * @param {number} user_id User ID
         * @param {number} teacher_id Teacher ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTeacherIdDelete(user_id: number, teacher_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdEvaluationsTeacherIdDelete(user_id, teacher_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersEvaluation
         * @param {number} user_id User ID
         * @param {number} teacher_id Teacher ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTeacherIdGet(user_id: number, teacher_id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20049> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdEvaluationsTeacherIdGet(user_id, teacher_id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update UsersEvaluation
         * @summary Update the specified UsersEvaluation in storage
         * @param {number} user_id User ID
         * @param {number} teacher_id Teacher ID
         * @param {UpdateUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTeacherIdPut(user_id: number, teacher_id: number, body?: UpdateUsersEvaluation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20050> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdEvaluationsTeacherIdPut(user_id, teacher_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UsersEvaluationTest
         * @summary Delete the specified UsersEvaluationTest in storage
         * @param {number} user_id User ID
         * @param {number} evaluations_question_id Evaluations Question ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestEvaluationsQuestionIdDelete(user_id: number, evaluations_question_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdEvaluationsTestEvaluationsQuestionIdDelete(user_id, evaluations_question_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersEvaluation
         * @param {number} user_id User ID
         * @param {number} evaluations_question_id Evaluations question ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestEvaluationsQuestionIdGet(user_id: number, evaluations_question_id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20062> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdEvaluationsTestEvaluationsQuestionIdGet(user_id, evaluations_question_id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update UsersEvaluationTest
         * @summary Update the specified UsersEvaluationTest in storage
         * @param {number} user_id User ID
         * @param {number} evaluations_question_id Evaluations question ID
         * @param {UpdateUsersEvaluationTest} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestEvaluationsQuestionIdPut(user_id: number, evaluations_question_id: number, body?: UpdateUsersEvaluationTest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20063> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdEvaluationsTestEvaluationsQuestionIdPut(user_id, evaluations_question_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store UsersEvaluationTest
         * @summary Store a newly created user evaluation test in storage
         * @param {number} user_id User ID
         * @param {NewUsersEvaluationTest} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestPost(user_id: number, body?: NewUsersEvaluationTest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20061> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdEvaluationsTestPost(user_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change UsersLesson State
         * @summary Change UsersLesson state
         * @param {number} user_id User ID
         * @param {string} secret User email in md5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsIcsGet(user_id: number, secret: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdLessonsIcsGet(user_id, secret, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UsersLesson
         * @summary Delete the specified UsersLesson in storage
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdDelete(user_id: number, lesson_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdLessonsLessonIdDelete(user_id, lesson_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersLesson
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdGet(user_id: number, lesson_id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20065> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdLessonsLessonIdGet(user_id, lesson_id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update UsersLesson
         * @summary Update the specified UsersLesson in storage
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {UpdateUsersLesson} [body] UsersLesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdPut(user_id: number, lesson_id: number, body?: UpdateUsersLesson, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20066> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdLessonsLessonIdPut(user_id, lesson_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change UsersLesson State
         * @summary Change UsersLesson state
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {UpdateUserLessonState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdStatePut(user_id: number, lesson_id: number, body?: UpdateUserLessonState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdLessonsLessonIdStatePut(user_id, lesson_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store Users
         * @summary Store a newly created user lessons in storage
         * @param {number} user_id User ID
         * @param {NewUsersLesson} [body] NewUsersLesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsPost(user_id: number, body?: NewUsersLesson, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20065> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdLessonsPost(user_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UsersMarker
         * @summary Delete the specified UsersMarker in storage
         * @param {number} user_id User ID
         * @param {string} code Marker code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersCodeDelete(user_id: number, code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdMarkersCodeDelete(user_id, code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersMarker
         * @param {number} user_id User ID
         * @param {string} code Marker Code
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersCodeGet(user_id: number, code: string, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20068> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdMarkersCodeGet(user_id, code, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update UsersMarker
         * @summary Update the specified UsersMarker in storage
         * @param {number} user_id User ID
         * @param {string} code Marker Code
         * @param {UpdateUsersMarker} [body] UsersMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersCodePut(user_id: number, code: string, body?: UpdateUsersMarker, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20069> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdMarkersCodePut(user_id, code, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store Users
         * @summary Store a newly created user markers in storage
         * @param {number} user_id User ID
         * @param {NewUsersMarker} [body] NewUsersMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersPost(user_id: number, body?: NewUsersMarker, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20068> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdMarkersPost(user_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UsersMedia
         * @summary Delete the specified UsersMedia in storage
         * @param {number} user_id User ID
         * @param {number} media_id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaMediaIdDelete(user_id: number, media_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdMediaMediaIdDelete(user_id, media_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersMedia
         * @summary Display the specified UsersMedia
         * @param {number} user_id User ID
         * @param {number} media_id Media ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaMediaIdGet(user_id: number, media_id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20072> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdMediaMediaIdGet(user_id, media_id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update UsersMedia
         * @summary Update the specified UsersMedia in storage
         * @param {number} user_id User ID
         * @param {number} media_id Media ID
         * @param {UpdateUsersMedia} [body] UsersMedia that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaMediaIdPost(user_id: number, media_id: number, body?: UpdateUsersMedia, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20073> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdMediaMediaIdPost(user_id, media_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store UsersMedia
         * @summary Store a newly created user document in storage
         * @param {number} user_id User ID
         * @param {NewUsersMedia} [body] UsersMedia that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaPost(user_id: number, body?: NewUsersMedia, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20071> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdMediaPost(user_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store Users
         * @summary Store a newly created user quiz in storage
         * @param {number} user_id User ID
         * @param {NewUsersQuiz} [body] NewUsersQuiz that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizPost(user_id: number, body?: NewUsersQuiz, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20075> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdQuizPost(user_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UsersQuiz
         * @summary Delete the specified UsersQuiz in storage
         * @param {number} user_id User ID
         * @param {number} quiz_id Lesson ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizQuizIdDelete(user_id: number, quiz_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdQuizQuizIdDelete(user_id, quiz_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersQuiz
         * @param {number} user_id User ID
         * @param {number} quiz_id Lesson ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizQuizIdGet(user_id: number, quiz_id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20075> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdQuizQuizIdGet(user_id, quiz_id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update UsersQuiz
         * @summary Update the specified UsersQuiz in storage
         * @param {number} user_id User ID
         * @param {number} quiz_id Lesson ID
         * @param {UpdateUsersQuiz} [body] UsersQuiz that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizQuizIdPut(user_id: number, quiz_id: number, body?: UpdateUsersQuiz, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20076> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdQuizQuizIdPut(user_id, quiz_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store Users
         * @summary Store a newly created user roles in storage
         * @param {number} user_id User ID
         * @param {NewUsersRole} [body] NewUsersRole that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesPost(user_id: number, body?: NewUsersRole, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20080> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdRolesPost(user_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UsersRole
         * @summary Delete the specified UsersRole in storage
         * @param {number} user_id User ID
         * @param {number} role Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesRoleDelete(user_id: number, role: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdRolesRoleDelete(user_id, role, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersRole
         * @param {number} user_id User ID
         * @param {number} role Role
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesRoleGet(user_id: number, role: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20080> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdRolesRoleGet(user_id, role, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update UsersRole
         * @summary Update the specified UsersRole in storage
         * @param {number} user_id User ID
         * @param {string} role Role
         * @param {UpdateUsersRole} [body] UsersRole that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesRolePut(user_id: number, role: string, body?: UpdateUsersRole, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20081> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersUserIdRolesRolePut(user_id, role, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all Users
         * @summary Get a listing of the Users.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {&#39;STUDENT&#39; | &#39;TEACHER&#39; | &#39;ADMIN&#39; | &#39;PARTNER&#39;} [role] role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, role?: 'STUDENT' | 'TEACHER' | 'ADMIN' | 'PARTNER', options?: any) {
            return UserApiFp(configuration).usersGet(offset, limit, search, sort_order, asc, _with, fields, scenario, role, options)(fetch, basePath);
        },
        /**
         * Get UsersAvailability
         * @summary Display the specified UsersAvailability
         * @param {number} id User ID
         * @param {number} availabilityId UsersAvailability ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesAvailabilityIdGet(id: number, availabilityId: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdAvailabilitiesAvailabilityIdGet(id, availabilityId, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Store UsersAvailability
         * @summary Store a newly created availability in storage
         * @param {number} id User ID
         * @param {Array&lt;NewUsersAvailability&gt;} [body] UsersAvailabilities that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesCollectionPost(id: number, body?: Array<NewUsersAvailability>, options?: any) {
            return UserApiFp(configuration).usersIdAvailabilitiesCollectionPost(id, body, options)(fetch, basePath);
        },
        /**
         * Get all availabilities for user
         * @summary Get a listing of the UsersAvailability.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdAvailabilitiesGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Store UsersAvailability
         * @summary Store a newly created availability in storage
         * @param {number} id User ID
         * @param {NewUsersAvailability} [body] UsersAvailability that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdAvailabilitiesPost(id: number, body?: NewUsersAvailability, options?: any) {
            return UserApiFp(configuration).usersIdAvailabilitiesPost(id, body, options)(fetch, basePath);
        },
        /**
         * Get UsersBalance
         * @summary Display the specified UsersBalance
         * @param {number} id User ID
         * @param {number} balanceId UsersBalance ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBalanceBalanceIdGet(id: number, balanceId: number, _with?: string, options?: any) {
            return UserApiFp(configuration).usersIdBalanceBalanceIdGet(id, balanceId, _with, options)(fetch, basePath);
        },
        /**
         * Get all balance history for user
         * @summary Get a listing of the UsersBalance.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBalanceGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, options?: any) {
            return UserApiFp(configuration).usersIdBalanceGet(id, offset, limit, search, sort_order, asc, _with, fields, options)(fetch, basePath);
        },
        /**
         * Create new transaction which change users balance.
         * @summary Change users balance.
         * @param {number} id User ID
         * @param {NewUsersBalance} [body] UsersBalance that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBalancePost(id: number, body?: NewUsersBalance, options?: any) {
            return UserApiFp(configuration).usersIdBalancePost(id, body, options)(fetch, basePath);
        },
        /**
         * Delete User
         * @summary Remove the specified User from storage
         * @param {number} id id of User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: number, options?: any) {
            return UserApiFp(configuration).usersIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get all documents for user
         * @summary Get a listing of the UsersDocuments.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDocumentsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdDocumentsGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get all evaluation for user
         * @summary Get a listing of the UserEvaluation.
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdEvaluationsCurrentGet(id: number, options?: any) {
            return UserApiFp(configuration).usersIdEvaluationsCurrentGet(id, options)(fetch, basePath);
        },
        /**
         * Get all evaluation for user
         * @summary Get a listing of the UserEvaluation.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdEvaluationsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdEvaluationsGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get all evaluation test for user
         * @summary Get a listing of the UserEvaluationTest.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdEvaluationsTestGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdEvaluationsTestGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get all availabilities for user
         * @summary Get a listing of the UsersAvailability.
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFreeAvailabilitiesGet(id: number, options?: any) {
            return UserApiFp(configuration).usersIdFreeAvailabilitiesGet(id, options)(fetch, basePath);
        },
        /**
         * Get User
         * @summary Display the specified User
         * @param {number} id id of User
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get all lessons for user
         * @summary Get a listing of the UserLessons.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLessonsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdLessonsGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get all markers for user
         * @summary Get a listing of the UsersMarker.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [type] Markers type
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMarkersGet(id: number, offset: number, limit: number, type?: string, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdMarkersGet(id, offset, limit, type, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get all media for user
         * @summary Get a listing of the UsersMedias.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMediaGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdMediaGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get User
         * @summary Get user packages
         * @param {number} id id of User
         * @param {&#39;asc&#39; | &#39;desc&#39;} [start] start sort
         * @param {&#39;asc&#39; | &#39;desc&#39;} [ends] ends sort
         * @param {&#39;active&#39; | &#39;finished&#39; | &#39;all&#39;} [state] state filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPackagesGet(id: number, start?: 'asc' | 'desc', ends?: 'asc' | 'desc', state?: 'active' | 'finished' | 'all', options?: any) {
            return UserApiFp(configuration).usersIdPackagesGet(id, start, ends, state, options)(fetch, basePath);
        },
        /**
         * Update User
         * @summary Update the specified User in storage
         * @param {number} id id of User
         * @param {UpdateUser} [body] User that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(id: number, body?: UpdateUser, options?: any) {
            return UserApiFp(configuration).usersIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Get all quiz for user
         * @summary Get a listing of the UserQuiz.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdQuizGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdQuizGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Get all rates for user
         * @summary Get a listing of the UsersRate.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRateGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdRateGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Store UsersRate
         * @summary Store a newly created rate in storage
         * @param {number} id User ID
         * @param {NewUsersRate} [body] UsersRate that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRatePost(id: number, body?: NewUsersRate, options?: any) {
            return UserApiFp(configuration).usersIdRatePost(id, body, options)(fetch, basePath);
        },
        /**
         * Get all roles for user
         * @summary Get a listing of the UserRole.
         * @param {number} id User ID
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRolesGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersIdRolesGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Change User State
         * @summary Change User state
         * @param {number} id id of User
         * @param {UpdateUserState} [body] User state that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdStatePut(id: number, body?: UpdateUserState, options?: any) {
            return UserApiFp(configuration).usersIdStatePut(id, body, options)(fetch, basePath);
        },
        /**
         * Store User
         * @summary Store a newly created User in storage
         * @param {NewUser} [body] User that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(body?: NewUser, options?: any) {
            return UserApiFp(configuration).usersPost(body, options)(fetch, basePath);
        },
        /**
         * Change users status.
         * @summary Change users status.
         * @param {&#39;online&#39; | &#39;offline&#39;} status Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStatusStatusPost(status: 'online' | 'offline', options?: any) {
            return UserApiFp(configuration).usersStatusStatusPost(status, options)(fetch, basePath);
        },
        /**
         * Delete UsersAvailability
         * @summary Delete the specified UsersAvailability in storage
         * @param {number} user_id User ID
         * @param {number} availability_id UsersAvailability ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAvailabilitiesAvailabilityIdDelete(user_id: number, availability_id: number, options?: any) {
            return UserApiFp(configuration).usersUserIdAvailabilitiesAvailabilityIdDelete(user_id, availability_id, options)(fetch, basePath);
        },
        /**
         * Store UsersDocument
         * @summary Store a newly created user document in storage
         * @param {number} user_id User ID
         * @param {NewUsersDocument} [body] UsersDocument that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsPost(user_id: number, body?: NewUsersDocument, options?: any) {
            return UserApiFp(configuration).usersUserIdDocumentsPost(user_id, body, options)(fetch, basePath);
        },
        /**
         * Delete UsersDocument
         * @summary Delete the specified UsersDocument in storage
         * @param {number} user_id User ID
         * @param {number} user_document_id User Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsUserDocumentIdDelete(user_id: number, user_document_id: number, options?: any) {
            return UserApiFp(configuration).usersUserIdDocumentsUserDocumentIdDelete(user_id, user_document_id, options)(fetch, basePath);
        },
        /**
         * Get UsersDocument
         * @summary Display the specified UsersDocument
         * @param {number} user_id User ID
         * @param {number} user_document_id User Document ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsUserDocumentIdGet(user_id: number, user_document_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersUserIdDocumentsUserDocumentIdGet(user_id, user_document_id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update UsersDocument
         * @summary Update the specified UsersDocument in storage
         * @param {number} user_id User ID
         * @param {number} user_document_id User Document ID
         * @param {UpdateUsersDocument} [body] UsersDocument that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDocumentsUserDocumentIdPost(user_id: number, user_document_id: number, body?: UpdateUsersDocument, options?: any) {
            return UserApiFp(configuration).usersUserIdDocumentsUserDocumentIdPost(user_id, user_document_id, body, options)(fetch, basePath);
        },
        /**
         * Store UsersEvaluation
         * @summary Store a newly created user evaluation in storage
         * @param {number} user_id User ID
         * @param {NewUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsPost(user_id: number, body?: NewUsersEvaluation, options?: any) {
            return UserApiFp(configuration).usersUserIdEvaluationsPost(user_id, body, options)(fetch, basePath);
        },
        /**
         * Delete UsersEvaluation
         * @summary Delete the specified UsersEvaluation in storage
         * @param {number} user_id User ID
         * @param {number} teacher_id Teacher ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTeacherIdDelete(user_id: number, teacher_id: number, options?: any) {
            return UserApiFp(configuration).usersUserIdEvaluationsTeacherIdDelete(user_id, teacher_id, options)(fetch, basePath);
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersEvaluation
         * @param {number} user_id User ID
         * @param {number} teacher_id Teacher ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTeacherIdGet(user_id: number, teacher_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersUserIdEvaluationsTeacherIdGet(user_id, teacher_id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update UsersEvaluation
         * @summary Update the specified UsersEvaluation in storage
         * @param {number} user_id User ID
         * @param {number} teacher_id Teacher ID
         * @param {UpdateUsersEvaluation} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTeacherIdPut(user_id: number, teacher_id: number, body?: UpdateUsersEvaluation, options?: any) {
            return UserApiFp(configuration).usersUserIdEvaluationsTeacherIdPut(user_id, teacher_id, body, options)(fetch, basePath);
        },
        /**
         * Delete UsersEvaluationTest
         * @summary Delete the specified UsersEvaluationTest in storage
         * @param {number} user_id User ID
         * @param {number} evaluations_question_id Evaluations Question ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestEvaluationsQuestionIdDelete(user_id: number, evaluations_question_id: number, options?: any) {
            return UserApiFp(configuration).usersUserIdEvaluationsTestEvaluationsQuestionIdDelete(user_id, evaluations_question_id, options)(fetch, basePath);
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersEvaluation
         * @param {number} user_id User ID
         * @param {number} evaluations_question_id Evaluations question ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestEvaluationsQuestionIdGet(user_id: number, evaluations_question_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersUserIdEvaluationsTestEvaluationsQuestionIdGet(user_id, evaluations_question_id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update UsersEvaluationTest
         * @summary Update the specified UsersEvaluationTest in storage
         * @param {number} user_id User ID
         * @param {number} evaluations_question_id Evaluations question ID
         * @param {UpdateUsersEvaluationTest} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestEvaluationsQuestionIdPut(user_id: number, evaluations_question_id: number, body?: UpdateUsersEvaluationTest, options?: any) {
            return UserApiFp(configuration).usersUserIdEvaluationsTestEvaluationsQuestionIdPut(user_id, evaluations_question_id, body, options)(fetch, basePath);
        },
        /**
         * Store UsersEvaluationTest
         * @summary Store a newly created user evaluation test in storage
         * @param {number} user_id User ID
         * @param {NewUsersEvaluationTest} [body] UsersEvaluation that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdEvaluationsTestPost(user_id: number, body?: NewUsersEvaluationTest, options?: any) {
            return UserApiFp(configuration).usersUserIdEvaluationsTestPost(user_id, body, options)(fetch, basePath);
        },
        /**
         * Change UsersLesson State
         * @summary Change UsersLesson state
         * @param {number} user_id User ID
         * @param {string} secret User email in md5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsIcsGet(user_id: number, secret: string, options?: any) {
            return UserApiFp(configuration).usersUserIdLessonsIcsGet(user_id, secret, options)(fetch, basePath);
        },
        /**
         * Delete UsersLesson
         * @summary Delete the specified UsersLesson in storage
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdDelete(user_id: number, lesson_id: number, options?: any) {
            return UserApiFp(configuration).usersUserIdLessonsLessonIdDelete(user_id, lesson_id, options)(fetch, basePath);
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersLesson
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdGet(user_id: number, lesson_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersUserIdLessonsLessonIdGet(user_id, lesson_id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update UsersLesson
         * @summary Update the specified UsersLesson in storage
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {UpdateUsersLesson} [body] UsersLesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdPut(user_id: number, lesson_id: number, body?: UpdateUsersLesson, options?: any) {
            return UserApiFp(configuration).usersUserIdLessonsLessonIdPut(user_id, lesson_id, body, options)(fetch, basePath);
        },
        /**
         * Change UsersLesson State
         * @summary Change UsersLesson state
         * @param {number} user_id User ID
         * @param {number} lesson_id Lesson ID
         * @param {UpdateUserLessonState} [body] Discount that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsLessonIdStatePut(user_id: number, lesson_id: number, body?: UpdateUserLessonState, options?: any) {
            return UserApiFp(configuration).usersUserIdLessonsLessonIdStatePut(user_id, lesson_id, body, options)(fetch, basePath);
        },
        /**
         * Store Users
         * @summary Store a newly created user lessons in storage
         * @param {number} user_id User ID
         * @param {NewUsersLesson} [body] NewUsersLesson that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdLessonsPost(user_id: number, body?: NewUsersLesson, options?: any) {
            return UserApiFp(configuration).usersUserIdLessonsPost(user_id, body, options)(fetch, basePath);
        },
        /**
         * Delete UsersMarker
         * @summary Delete the specified UsersMarker in storage
         * @param {number} user_id User ID
         * @param {string} code Marker code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersCodeDelete(user_id: number, code: string, options?: any) {
            return UserApiFp(configuration).usersUserIdMarkersCodeDelete(user_id, code, options)(fetch, basePath);
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersMarker
         * @param {number} user_id User ID
         * @param {string} code Marker Code
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersCodeGet(user_id: number, code: string, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersUserIdMarkersCodeGet(user_id, code, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update UsersMarker
         * @summary Update the specified UsersMarker in storage
         * @param {number} user_id User ID
         * @param {string} code Marker Code
         * @param {UpdateUsersMarker} [body] UsersMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersCodePut(user_id: number, code: string, body?: UpdateUsersMarker, options?: any) {
            return UserApiFp(configuration).usersUserIdMarkersCodePut(user_id, code, body, options)(fetch, basePath);
        },
        /**
         * Store Users
         * @summary Store a newly created user markers in storage
         * @param {number} user_id User ID
         * @param {NewUsersMarker} [body] NewUsersMarker that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMarkersPost(user_id: number, body?: NewUsersMarker, options?: any) {
            return UserApiFp(configuration).usersUserIdMarkersPost(user_id, body, options)(fetch, basePath);
        },
        /**
         * Delete UsersMedia
         * @summary Delete the specified UsersMedia in storage
         * @param {number} user_id User ID
         * @param {number} media_id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaMediaIdDelete(user_id: number, media_id: number, options?: any) {
            return UserApiFp(configuration).usersUserIdMediaMediaIdDelete(user_id, media_id, options)(fetch, basePath);
        },
        /**
         * Get UsersMedia
         * @summary Display the specified UsersMedia
         * @param {number} user_id User ID
         * @param {number} media_id Media ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaMediaIdGet(user_id: number, media_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersUserIdMediaMediaIdGet(user_id, media_id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update UsersMedia
         * @summary Update the specified UsersMedia in storage
         * @param {number} user_id User ID
         * @param {number} media_id Media ID
         * @param {UpdateUsersMedia} [body] UsersMedia that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaMediaIdPost(user_id: number, media_id: number, body?: UpdateUsersMedia, options?: any) {
            return UserApiFp(configuration).usersUserIdMediaMediaIdPost(user_id, media_id, body, options)(fetch, basePath);
        },
        /**
         * Store UsersMedia
         * @summary Store a newly created user document in storage
         * @param {number} user_id User ID
         * @param {NewUsersMedia} [body] UsersMedia that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdMediaPost(user_id: number, body?: NewUsersMedia, options?: any) {
            return UserApiFp(configuration).usersUserIdMediaPost(user_id, body, options)(fetch, basePath);
        },
        /**
         * Store Users
         * @summary Store a newly created user quiz in storage
         * @param {number} user_id User ID
         * @param {NewUsersQuiz} [body] NewUsersQuiz that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizPost(user_id: number, body?: NewUsersQuiz, options?: any) {
            return UserApiFp(configuration).usersUserIdQuizPost(user_id, body, options)(fetch, basePath);
        },
        /**
         * Delete UsersQuiz
         * @summary Delete the specified UsersQuiz in storage
         * @param {number} user_id User ID
         * @param {number} quiz_id Lesson ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizQuizIdDelete(user_id: number, quiz_id: number, options?: any) {
            return UserApiFp(configuration).usersUserIdQuizQuizIdDelete(user_id, quiz_id, options)(fetch, basePath);
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersQuiz
         * @param {number} user_id User ID
         * @param {number} quiz_id Lesson ID
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizQuizIdGet(user_id: number, quiz_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersUserIdQuizQuizIdGet(user_id, quiz_id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update UsersQuiz
         * @summary Update the specified UsersQuiz in storage
         * @param {number} user_id User ID
         * @param {number} quiz_id Lesson ID
         * @param {UpdateUsersQuiz} [body] UsersQuiz that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdQuizQuizIdPut(user_id: number, quiz_id: number, body?: UpdateUsersQuiz, options?: any) {
            return UserApiFp(configuration).usersUserIdQuizQuizIdPut(user_id, quiz_id, body, options)(fetch, basePath);
        },
        /**
         * Store Users
         * @summary Store a newly created user roles in storage
         * @param {number} user_id User ID
         * @param {NewUsersRole} [body] NewUsersRole that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesPost(user_id: number, body?: NewUsersRole, options?: any) {
            return UserApiFp(configuration).usersUserIdRolesPost(user_id, body, options)(fetch, basePath);
        },
        /**
         * Delete UsersRole
         * @summary Delete the specified UsersRole in storage
         * @param {number} user_id User ID
         * @param {number} role Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesRoleDelete(user_id: number, role: number, options?: any) {
            return UserApiFp(configuration).usersUserIdRolesRoleDelete(user_id, role, options)(fetch, basePath);
        },
        /**
         * Get UsersEvaluation
         * @summary Display the specified UsersRole
         * @param {number} user_id User ID
         * @param {number} role Role
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesRoleGet(user_id: number, role: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserApiFp(configuration).usersUserIdRolesRoleGet(user_id, role, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update UsersRole
         * @summary Update the specified UsersRole in storage
         * @param {number} user_id User ID
         * @param {string} role Role
         * @param {UpdateUsersRole} [body] UsersRole that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdRolesRolePut(user_id: number, role: string, body?: UpdateUsersRole, options?: any) {
            return UserApiFp(configuration).usersUserIdRolesRolePut(user_id, role, body, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get all Users
     * @summary Get a listing of the Users.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {} [role] role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersGet(offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, role?: 'STUDENT' | 'TEACHER' | 'ADMIN' | 'PARTNER', options?: any) {
        return UserApiFp(this.configuration).usersGet(offset, limit, search, sort_order, asc, _with, fields, scenario, role, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersAvailability
     * @summary Display the specified UsersAvailability
     * @param {} id User ID
     * @param {} availabilityId UsersAvailability ID
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdAvailabilitiesAvailabilityIdGet(id: number, availabilityId: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdAvailabilitiesAvailabilityIdGet(id, availabilityId, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Store UsersAvailability
     * @summary Store a newly created availability in storage
     * @param {} id User ID
     * @param {} [body] UsersAvailabilities that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdAvailabilitiesCollectionPost(id: number, body?: Array<NewUsersAvailability>, options?: any) {
        return UserApiFp(this.configuration).usersIdAvailabilitiesCollectionPost(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get all availabilities for user
     * @summary Get a listing of the UsersAvailability.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdAvailabilitiesGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdAvailabilitiesGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Store UsersAvailability
     * @summary Store a newly created availability in storage
     * @param {} id User ID
     * @param {} [body] UsersAvailability that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdAvailabilitiesPost(id: number, body?: NewUsersAvailability, options?: any) {
        return UserApiFp(this.configuration).usersIdAvailabilitiesPost(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersBalance
     * @summary Display the specified UsersBalance
     * @param {} id User ID
     * @param {} balanceId UsersBalance ID
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdBalanceBalanceIdGet(id: number, balanceId: number, _with?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdBalanceBalanceIdGet(id, balanceId, _with, options)(this.fetch, this.basePath);
    }

    /**
     * Get all balance history for user
     * @summary Get a listing of the UsersBalance.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdBalanceGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdBalanceGet(id, offset, limit, search, sort_order, asc, _with, fields, options)(this.fetch, this.basePath);
    }

    /**
     * Create new transaction which change users balance.
     * @summary Change users balance.
     * @param {} id User ID
     * @param {} [body] UsersBalance that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdBalancePost(id: number, body?: NewUsersBalance, options?: any) {
        return UserApiFp(this.configuration).usersIdBalancePost(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete User
     * @summary Remove the specified User from storage
     * @param {} id id of User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdDelete(id: number, options?: any) {
        return UserApiFp(this.configuration).usersIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get all documents for user
     * @summary Get a listing of the UsersDocuments.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdDocumentsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdDocumentsGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get all evaluation for user
     * @summary Get a listing of the UserEvaluation.
     * @param {} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdEvaluationsCurrentGet(id: number, options?: any) {
        return UserApiFp(this.configuration).usersIdEvaluationsCurrentGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get all evaluation for user
     * @summary Get a listing of the UserEvaluation.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdEvaluationsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdEvaluationsGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get all evaluation test for user
     * @summary Get a listing of the UserEvaluationTest.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdEvaluationsTestGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdEvaluationsTestGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get all availabilities for user
     * @summary Get a listing of the UsersAvailability.
     * @param {} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdFreeAvailabilitiesGet(id: number, options?: any) {
        return UserApiFp(this.configuration).usersIdFreeAvailabilitiesGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get User
     * @summary Display the specified User
     * @param {} id id of User
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get all lessons for user
     * @summary Get a listing of the UserLessons.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdLessonsGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdLessonsGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get all markers for user
     * @summary Get a listing of the UsersMarker.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [type] Markers type
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdMarkersGet(id: number, offset: number, limit: number, type?: string, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdMarkersGet(id, offset, limit, type, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get all media for user
     * @summary Get a listing of the UsersMedias.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdMediaGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdMediaGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get User
     * @summary Get user packages
     * @param {} id id of User
     * @param {} [start] start sort
     * @param {} [ends] ends sort
     * @param {} [state] state filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdPackagesGet(id: number, start?: 'asc' | 'desc', ends?: 'asc' | 'desc', state?: 'active' | 'finished' | 'all', options?: any) {
        return UserApiFp(this.configuration).usersIdPackagesGet(id, start, ends, state, options)(this.fetch, this.basePath);
    }

    /**
     * Update User
     * @summary Update the specified User in storage
     * @param {} id id of User
     * @param {} [body] User that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdPut(id: number, body?: UpdateUser, options?: any) {
        return UserApiFp(this.configuration).usersIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get all quiz for user
     * @summary Get a listing of the UserQuiz.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdQuizGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdQuizGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Get all rates for user
     * @summary Get a listing of the UsersRate.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdRateGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdRateGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Store UsersRate
     * @summary Store a newly created rate in storage
     * @param {} id User ID
     * @param {} [body] UsersRate that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdRatePost(id: number, body?: NewUsersRate, options?: any) {
        return UserApiFp(this.configuration).usersIdRatePost(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get all roles for user
     * @summary Get a listing of the UserRole.
     * @param {} id User ID
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdRolesGet(id: number, offset: number, limit: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersIdRolesGet(id, offset, limit, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Change User State
     * @summary Change User state
     * @param {} id id of User
     * @param {} [body] User state that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdStatePut(id: number, body?: UpdateUserState, options?: any) {
        return UserApiFp(this.configuration).usersIdStatePut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store User
     * @summary Store a newly created User in storage
     * @param {} [body] User that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersPost(body?: NewUser, options?: any) {
        return UserApiFp(this.configuration).usersPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Change users status.
     * @summary Change users status.
     * @param {} status Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersStatusStatusPost(status: 'online' | 'offline', options?: any) {
        return UserApiFp(this.configuration).usersStatusStatusPost(status, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UsersAvailability
     * @summary Delete the specified UsersAvailability in storage
     * @param {} user_id User ID
     * @param {} availability_id UsersAvailability ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdAvailabilitiesAvailabilityIdDelete(user_id: number, availability_id: number, options?: any) {
        return UserApiFp(this.configuration).usersUserIdAvailabilitiesAvailabilityIdDelete(user_id, availability_id, options)(this.fetch, this.basePath);
    }

    /**
     * Store UsersDocument
     * @summary Store a newly created user document in storage
     * @param {} user_id User ID
     * @param {} [body] UsersDocument that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdDocumentsPost(user_id: number, body?: NewUsersDocument, options?: any) {
        return UserApiFp(this.configuration).usersUserIdDocumentsPost(user_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UsersDocument
     * @summary Delete the specified UsersDocument in storage
     * @param {} user_id User ID
     * @param {} user_document_id User Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdDocumentsUserDocumentIdDelete(user_id: number, user_document_id: number, options?: any) {
        return UserApiFp(this.configuration).usersUserIdDocumentsUserDocumentIdDelete(user_id, user_document_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersDocument
     * @summary Display the specified UsersDocument
     * @param {} user_id User ID
     * @param {} user_document_id User Document ID
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdDocumentsUserDocumentIdGet(user_id: number, user_document_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersUserIdDocumentsUserDocumentIdGet(user_id, user_document_id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update UsersDocument
     * @summary Update the specified UsersDocument in storage
     * @param {} user_id User ID
     * @param {} user_document_id User Document ID
     * @param {} [body] UsersDocument that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdDocumentsUserDocumentIdPost(user_id: number, user_document_id: number, body?: UpdateUsersDocument, options?: any) {
        return UserApiFp(this.configuration).usersUserIdDocumentsUserDocumentIdPost(user_id, user_document_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store UsersEvaluation
     * @summary Store a newly created user evaluation in storage
     * @param {} user_id User ID
     * @param {} [body] UsersEvaluation that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdEvaluationsPost(user_id: number, body?: NewUsersEvaluation, options?: any) {
        return UserApiFp(this.configuration).usersUserIdEvaluationsPost(user_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UsersEvaluation
     * @summary Delete the specified UsersEvaluation in storage
     * @param {} user_id User ID
     * @param {} teacher_id Teacher ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdEvaluationsTeacherIdDelete(user_id: number, teacher_id: number, options?: any) {
        return UserApiFp(this.configuration).usersUserIdEvaluationsTeacherIdDelete(user_id, teacher_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersEvaluation
     * @summary Display the specified UsersEvaluation
     * @param {} user_id User ID
     * @param {} teacher_id Teacher ID
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdEvaluationsTeacherIdGet(user_id: number, teacher_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersUserIdEvaluationsTeacherIdGet(user_id, teacher_id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update UsersEvaluation
     * @summary Update the specified UsersEvaluation in storage
     * @param {} user_id User ID
     * @param {} teacher_id Teacher ID
     * @param {} [body] UsersEvaluation that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdEvaluationsTeacherIdPut(user_id: number, teacher_id: number, body?: UpdateUsersEvaluation, options?: any) {
        return UserApiFp(this.configuration).usersUserIdEvaluationsTeacherIdPut(user_id, teacher_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UsersEvaluationTest
     * @summary Delete the specified UsersEvaluationTest in storage
     * @param {} user_id User ID
     * @param {} evaluations_question_id Evaluations Question ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdEvaluationsTestEvaluationsQuestionIdDelete(user_id: number, evaluations_question_id: number, options?: any) {
        return UserApiFp(this.configuration).usersUserIdEvaluationsTestEvaluationsQuestionIdDelete(user_id, evaluations_question_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersEvaluation
     * @summary Display the specified UsersEvaluation
     * @param {} user_id User ID
     * @param {} evaluations_question_id Evaluations question ID
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdEvaluationsTestEvaluationsQuestionIdGet(user_id: number, evaluations_question_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersUserIdEvaluationsTestEvaluationsQuestionIdGet(user_id, evaluations_question_id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update UsersEvaluationTest
     * @summary Update the specified UsersEvaluationTest in storage
     * @param {} user_id User ID
     * @param {} evaluations_question_id Evaluations question ID
     * @param {} [body] UsersEvaluation that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdEvaluationsTestEvaluationsQuestionIdPut(user_id: number, evaluations_question_id: number, body?: UpdateUsersEvaluationTest, options?: any) {
        return UserApiFp(this.configuration).usersUserIdEvaluationsTestEvaluationsQuestionIdPut(user_id, evaluations_question_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store UsersEvaluationTest
     * @summary Store a newly created user evaluation test in storage
     * @param {} user_id User ID
     * @param {} [body] UsersEvaluation that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdEvaluationsTestPost(user_id: number, body?: NewUsersEvaluationTest, options?: any) {
        return UserApiFp(this.configuration).usersUserIdEvaluationsTestPost(user_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Change UsersLesson State
     * @summary Change UsersLesson state
     * @param {} user_id User ID
     * @param {} secret User email in md5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdLessonsIcsGet(user_id: number, secret: string, options?: any) {
        return UserApiFp(this.configuration).usersUserIdLessonsIcsGet(user_id, secret, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UsersLesson
     * @summary Delete the specified UsersLesson in storage
     * @param {} user_id User ID
     * @param {} lesson_id Lesson ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdLessonsLessonIdDelete(user_id: number, lesson_id: number, options?: any) {
        return UserApiFp(this.configuration).usersUserIdLessonsLessonIdDelete(user_id, lesson_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersEvaluation
     * @summary Display the specified UsersLesson
     * @param {} user_id User ID
     * @param {} lesson_id Lesson ID
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdLessonsLessonIdGet(user_id: number, lesson_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersUserIdLessonsLessonIdGet(user_id, lesson_id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update UsersLesson
     * @summary Update the specified UsersLesson in storage
     * @param {} user_id User ID
     * @param {} lesson_id Lesson ID
     * @param {} [body] UsersLesson that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdLessonsLessonIdPut(user_id: number, lesson_id: number, body?: UpdateUsersLesson, options?: any) {
        return UserApiFp(this.configuration).usersUserIdLessonsLessonIdPut(user_id, lesson_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Change UsersLesson State
     * @summary Change UsersLesson state
     * @param {} user_id User ID
     * @param {} lesson_id Lesson ID
     * @param {} [body] Discount that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdLessonsLessonIdStatePut(user_id: number, lesson_id: number, body?: UpdateUserLessonState, options?: any) {
        return UserApiFp(this.configuration).usersUserIdLessonsLessonIdStatePut(user_id, lesson_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store Users
     * @summary Store a newly created user lessons in storage
     * @param {} user_id User ID
     * @param {} [body] NewUsersLesson that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdLessonsPost(user_id: number, body?: NewUsersLesson, options?: any) {
        return UserApiFp(this.configuration).usersUserIdLessonsPost(user_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UsersMarker
     * @summary Delete the specified UsersMarker in storage
     * @param {} user_id User ID
     * @param {} code Marker code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdMarkersCodeDelete(user_id: number, code: string, options?: any) {
        return UserApiFp(this.configuration).usersUserIdMarkersCodeDelete(user_id, code, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersEvaluation
     * @summary Display the specified UsersMarker
     * @param {} user_id User ID
     * @param {} code Marker Code
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdMarkersCodeGet(user_id: number, code: string, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersUserIdMarkersCodeGet(user_id, code, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update UsersMarker
     * @summary Update the specified UsersMarker in storage
     * @param {} user_id User ID
     * @param {} code Marker Code
     * @param {} [body] UsersMarker that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdMarkersCodePut(user_id: number, code: string, body?: UpdateUsersMarker, options?: any) {
        return UserApiFp(this.configuration).usersUserIdMarkersCodePut(user_id, code, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store Users
     * @summary Store a newly created user markers in storage
     * @param {} user_id User ID
     * @param {} [body] NewUsersMarker that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdMarkersPost(user_id: number, body?: NewUsersMarker, options?: any) {
        return UserApiFp(this.configuration).usersUserIdMarkersPost(user_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UsersMedia
     * @summary Delete the specified UsersMedia in storage
     * @param {} user_id User ID
     * @param {} media_id Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdMediaMediaIdDelete(user_id: number, media_id: number, options?: any) {
        return UserApiFp(this.configuration).usersUserIdMediaMediaIdDelete(user_id, media_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersMedia
     * @summary Display the specified UsersMedia
     * @param {} user_id User ID
     * @param {} media_id Media ID
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdMediaMediaIdGet(user_id: number, media_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersUserIdMediaMediaIdGet(user_id, media_id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update UsersMedia
     * @summary Update the specified UsersMedia in storage
     * @param {} user_id User ID
     * @param {} media_id Media ID
     * @param {} [body] UsersMedia that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdMediaMediaIdPost(user_id: number, media_id: number, body?: UpdateUsersMedia, options?: any) {
        return UserApiFp(this.configuration).usersUserIdMediaMediaIdPost(user_id, media_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store UsersMedia
     * @summary Store a newly created user document in storage
     * @param {} user_id User ID
     * @param {} [body] UsersMedia that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdMediaPost(user_id: number, body?: NewUsersMedia, options?: any) {
        return UserApiFp(this.configuration).usersUserIdMediaPost(user_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store Users
     * @summary Store a newly created user quiz in storage
     * @param {} user_id User ID
     * @param {} [body] NewUsersQuiz that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdQuizPost(user_id: number, body?: NewUsersQuiz, options?: any) {
        return UserApiFp(this.configuration).usersUserIdQuizPost(user_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UsersQuiz
     * @summary Delete the specified UsersQuiz in storage
     * @param {} user_id User ID
     * @param {} quiz_id Lesson ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdQuizQuizIdDelete(user_id: number, quiz_id: number, options?: any) {
        return UserApiFp(this.configuration).usersUserIdQuizQuizIdDelete(user_id, quiz_id, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersEvaluation
     * @summary Display the specified UsersQuiz
     * @param {} user_id User ID
     * @param {} quiz_id Lesson ID
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdQuizQuizIdGet(user_id: number, quiz_id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersUserIdQuizQuizIdGet(user_id, quiz_id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update UsersQuiz
     * @summary Update the specified UsersQuiz in storage
     * @param {} user_id User ID
     * @param {} quiz_id Lesson ID
     * @param {} [body] UsersQuiz that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdQuizQuizIdPut(user_id: number, quiz_id: number, body?: UpdateUsersQuiz, options?: any) {
        return UserApiFp(this.configuration).usersUserIdQuizQuizIdPut(user_id, quiz_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store Users
     * @summary Store a newly created user roles in storage
     * @param {} user_id User ID
     * @param {} [body] NewUsersRole that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdRolesPost(user_id: number, body?: NewUsersRole, options?: any) {
        return UserApiFp(this.configuration).usersUserIdRolesPost(user_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UsersRole
     * @summary Delete the specified UsersRole in storage
     * @param {} user_id User ID
     * @param {} role Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdRolesRoleDelete(user_id: number, role: number, options?: any) {
        return UserApiFp(this.configuration).usersUserIdRolesRoleDelete(user_id, role, options)(this.fetch, this.basePath);
    }

    /**
     * Get UsersEvaluation
     * @summary Display the specified UsersRole
     * @param {} user_id User ID
     * @param {} role Role
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdRolesRoleGet(user_id: number, role: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserApiFp(this.configuration).usersUserIdRolesRoleGet(user_id, role, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update UsersRole
     * @summary Update the specified UsersRole in storage
     * @param {} user_id User ID
     * @param {} role Role
     * @param {} [body] UsersRole that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersUserIdRolesRolePut(user_id: number, role: string, body?: UpdateUsersRole, options?: any) {
        return UserApiFp(this.configuration).usersUserIdRolesRolePut(user_id, role, body, options)(this.fetch, this.basePath);
    }

}

/**
 * UserToUserFeedbackApi - fetch parameter creator
 * @export
 */
export const UserToUserFeedbackApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all UserToUserFeedback
         * @summary Get a listing of the UserToUserFeedback.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {number} [user_id] User ID
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksGet(offset: number, limit: number, user_id?: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling feedbacksGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling feedbacksGet.');
            }
            const localVarPath = `/feedbacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (user_id !== undefined) {
                localVarQueryParameter['user_id'] = user_id;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort_order !== undefined) {
                localVarQueryParameter['sort_order'] = sort_order;
            }

            if (asc !== undefined) {
                localVarQueryParameter['asc'] = asc;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UserToUserFeedback
         * @summary Remove the specified UserToUserFeedback from storage
         * @param {number} id id of UserToUserFeedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling feedbacksIdDelete.');
            }
            const localVarPath = `/feedbacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UserToUserFeedback
         * @summary Display the specified UserToUserFeedback
         * @param {number} id id of UserToUserFeedback
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksIdGet(id: number, _with?: string, fields?: string, scenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling feedbacksIdGet.');
            }
            const localVarPath = `/feedbacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UserToUserFeedback
         * @summary Update the specified UserToUserFeedback in storage
         * @param {number} id id of UserToUserFeedback
         * @param {NewUserToUserFeedback} [body] UserToUserFeedback that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksIdPut(id: number, body?: NewUserToUserFeedback, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling feedbacksIdPut.');
            }
            const localVarPath = `/feedbacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUserToUserFeedback" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store UserToUserFeedback
         * @summary Store a newly created UserToUserFeedback in storage
         * @param {NewUserToUserFeedback} [body] UserToUserFeedback that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksPost(body?: NewUserToUserFeedback, options: any = {}): FetchArgs {
            const localVarPath = `/feedbacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oauth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUserToUserFeedback" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserToUserFeedbackApi - functional programming interface
 * @export
 */
export const UserToUserFeedbackApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all UserToUserFeedback
         * @summary Get a listing of the UserToUserFeedback.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {number} [user_id] User ID
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksGet(offset: number, limit: number, user_id?: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20051> {
            const localVarFetchArgs = UserToUserFeedbackApiFetchParamCreator(configuration).feedbacksGet(offset, limit, user_id, search, sort_order, asc, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete UserToUserFeedback
         * @summary Remove the specified UserToUserFeedback from storage
         * @param {number} id id of UserToUserFeedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = UserToUserFeedbackApiFetchParamCreator(configuration).feedbacksIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UserToUserFeedback
         * @summary Display the specified UserToUserFeedback
         * @param {number} id id of UserToUserFeedback
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20052> {
            const localVarFetchArgs = UserToUserFeedbackApiFetchParamCreator(configuration).feedbacksIdGet(id, _with, fields, scenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update UserToUserFeedback
         * @summary Update the specified UserToUserFeedback in storage
         * @param {number} id id of UserToUserFeedback
         * @param {NewUserToUserFeedback} [body] UserToUserFeedback that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksIdPut(id: number, body?: NewUserToUserFeedback, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20052> {
            const localVarFetchArgs = UserToUserFeedbackApiFetchParamCreator(configuration).feedbacksIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store UserToUserFeedback
         * @summary Store a newly created UserToUserFeedback in storage
         * @param {NewUserToUserFeedback} [body] UserToUserFeedback that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksPost(body?: NewUserToUserFeedback, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20052> {
            const localVarFetchArgs = UserToUserFeedbackApiFetchParamCreator(configuration).feedbacksPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserToUserFeedbackApi - factory interface
 * @export
 */
export const UserToUserFeedbackApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all UserToUserFeedback
         * @summary Get a listing of the UserToUserFeedback.
         * @param {number} offset Offset
         * @param {number} limit Limit
         * @param {number} [user_id] User ID
         * @param {string} [search] Search
         * @param {string} [sort_order] SortOrder
         * @param {&#39;asc&#39; | &#39;desc&#39;} [asc] asc
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksGet(offset: number, limit: number, user_id?: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserToUserFeedbackApiFp(configuration).feedbacksGet(offset, limit, user_id, search, sort_order, asc, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Delete UserToUserFeedback
         * @summary Remove the specified UserToUserFeedback from storage
         * @param {number} id id of UserToUserFeedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksIdDelete(id: number, options?: any) {
            return UserToUserFeedbackApiFp(configuration).feedbacksIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Get UserToUserFeedback
         * @summary Display the specified UserToUserFeedback
         * @param {number} id id of UserToUserFeedback
         * @param {string} [_with] Entities separated by &#x60;,&#x60;
         * @param {string} [fields] Fields separated by &#x60;,&#x60;
         * @param {string} [scenario] Scenario
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
            return UserToUserFeedbackApiFp(configuration).feedbacksIdGet(id, _with, fields, scenario, options)(fetch, basePath);
        },
        /**
         * Update UserToUserFeedback
         * @summary Update the specified UserToUserFeedback in storage
         * @param {number} id id of UserToUserFeedback
         * @param {NewUserToUserFeedback} [body] UserToUserFeedback that should be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksIdPut(id: number, body?: NewUserToUserFeedback, options?: any) {
            return UserToUserFeedbackApiFp(configuration).feedbacksIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Store UserToUserFeedback
         * @summary Store a newly created UserToUserFeedback in storage
         * @param {NewUserToUserFeedback} [body] UserToUserFeedback that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbacksPost(body?: NewUserToUserFeedback, options?: any) {
            return UserToUserFeedbackApiFp(configuration).feedbacksPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * UserToUserFeedbackApi - object-oriented interface
 * @export
 * @class UserToUserFeedbackApi
 * @extends {BaseAPI}
 */
export class UserToUserFeedbackApi extends BaseAPI {
    /**
     * Get all UserToUserFeedback
     * @summary Get a listing of the UserToUserFeedback.
     * @param {} offset Offset
     * @param {} limit Limit
     * @param {} [user_id] User ID
     * @param {} [search] Search
     * @param {} [sort_order] SortOrder
     * @param {} [asc] asc
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserToUserFeedbackApi
     */
    public feedbacksGet(offset: number, limit: number, user_id?: number, search?: string, sort_order?: string, asc?: 'asc' | 'desc', _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserToUserFeedbackApiFp(this.configuration).feedbacksGet(offset, limit, user_id, search, sort_order, asc, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Delete UserToUserFeedback
     * @summary Remove the specified UserToUserFeedback from storage
     * @param {} id id of UserToUserFeedback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserToUserFeedbackApi
     */
    public feedbacksIdDelete(id: number, options?: any) {
        return UserToUserFeedbackApiFp(this.configuration).feedbacksIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get UserToUserFeedback
     * @summary Display the specified UserToUserFeedback
     * @param {} id id of UserToUserFeedback
     * @param {} [_with] Entities separated by &#x60;,&#x60;
     * @param {} [fields] Fields separated by &#x60;,&#x60;
     * @param {} [scenario] Scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserToUserFeedbackApi
     */
    public feedbacksIdGet(id: number, _with?: string, fields?: string, scenario?: string, options?: any) {
        return UserToUserFeedbackApiFp(this.configuration).feedbacksIdGet(id, _with, fields, scenario, options)(this.fetch, this.basePath);
    }

    /**
     * Update UserToUserFeedback
     * @summary Update the specified UserToUserFeedback in storage
     * @param {} id id of UserToUserFeedback
     * @param {} [body] UserToUserFeedback that should be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserToUserFeedbackApi
     */
    public feedbacksIdPut(id: number, body?: NewUserToUserFeedback, options?: any) {
        return UserToUserFeedbackApiFp(this.configuration).feedbacksIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store UserToUserFeedback
     * @summary Store a newly created UserToUserFeedback in storage
     * @param {} [body] UserToUserFeedback that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserToUserFeedbackApi
     */
    public feedbacksPost(body?: NewUserToUserFeedback, options?: any) {
        return UserToUserFeedbackApiFp(this.configuration).feedbacksPost(body, options)(this.fetch, this.basePath);
    }

}

